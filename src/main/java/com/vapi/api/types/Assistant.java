/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = Assistant.Builder.class)
public final class Assistant {
    private final Optional<AssistantTranscriber> transcriber;

    private final Optional<AssistantModel> model;

    private final Optional<AssistantVoice> voice;

    private final Optional<String> firstMessage;

    private final Optional<Boolean> firstMessageInterruptionsEnabled;

    private final Optional<AssistantFirstMessageMode> firstMessageMode;

    private final Optional<AssistantVoicemailDetection> voicemailDetection;

    private final Optional<List<AssistantClientMessagesItem>> clientMessages;

    private final Optional<List<AssistantServerMessagesItem>> serverMessages;

    private final Optional<Double> silenceTimeoutSeconds;

    private final Optional<Double> maxDurationSeconds;

    private final Optional<AssistantBackgroundSound> backgroundSound;

    private final Optional<Boolean> backgroundDenoisingEnabled;

    private final Optional<Boolean> modelOutputInMessagesEnabled;

    private final Optional<List<TransportConfigurationTwilio>> transportConfigurations;

    private final Optional<LangfuseObservabilityPlan> observabilityPlan;

    private final Optional<List<AssistantCredentialsItem>> credentials;

    private final Optional<String> name;

    private final Optional<String> voicemailMessage;

    private final Optional<String> endCallMessage;

    private final Optional<List<String>> endCallPhrases;

    private final Optional<CompliancePlan> compliancePlan;

    private final Optional<Map<String, Object>> metadata;

    private final Optional<AnalysisPlan> analysisPlan;

    private final Optional<ArtifactPlan> artifactPlan;

    private final Optional<MessagePlan> messagePlan;

    private final Optional<StartSpeakingPlan> startSpeakingPlan;

    private final Optional<StopSpeakingPlan> stopSpeakingPlan;

    private final Optional<MonitorPlan> monitorPlan;

    private final Optional<List<String>> credentialIds;

    private final Optional<Server> server;

    private final Optional<List<AssistantHooks>> hooks;

    private final Optional<KeypadInputPlan> keypadInputPlan;

    private final String id;

    private final String orgId;

    private final OffsetDateTime createdAt;

    private final OffsetDateTime updatedAt;

    private final Map<String, Object> additionalProperties;

    private Assistant(
            Optional<AssistantTranscriber> transcriber,
            Optional<AssistantModel> model,
            Optional<AssistantVoice> voice,
            Optional<String> firstMessage,
            Optional<Boolean> firstMessageInterruptionsEnabled,
            Optional<AssistantFirstMessageMode> firstMessageMode,
            Optional<AssistantVoicemailDetection> voicemailDetection,
            Optional<List<AssistantClientMessagesItem>> clientMessages,
            Optional<List<AssistantServerMessagesItem>> serverMessages,
            Optional<Double> silenceTimeoutSeconds,
            Optional<Double> maxDurationSeconds,
            Optional<AssistantBackgroundSound> backgroundSound,
            Optional<Boolean> backgroundDenoisingEnabled,
            Optional<Boolean> modelOutputInMessagesEnabled,
            Optional<List<TransportConfigurationTwilio>> transportConfigurations,
            Optional<LangfuseObservabilityPlan> observabilityPlan,
            Optional<List<AssistantCredentialsItem>> credentials,
            Optional<String> name,
            Optional<String> voicemailMessage,
            Optional<String> endCallMessage,
            Optional<List<String>> endCallPhrases,
            Optional<CompliancePlan> compliancePlan,
            Optional<Map<String, Object>> metadata,
            Optional<AnalysisPlan> analysisPlan,
            Optional<ArtifactPlan> artifactPlan,
            Optional<MessagePlan> messagePlan,
            Optional<StartSpeakingPlan> startSpeakingPlan,
            Optional<StopSpeakingPlan> stopSpeakingPlan,
            Optional<MonitorPlan> monitorPlan,
            Optional<List<String>> credentialIds,
            Optional<Server> server,
            Optional<List<AssistantHooks>> hooks,
            Optional<KeypadInputPlan> keypadInputPlan,
            String id,
            String orgId,
            OffsetDateTime createdAt,
            OffsetDateTime updatedAt,
            Map<String, Object> additionalProperties) {
        this.transcriber = transcriber;
        this.model = model;
        this.voice = voice;
        this.firstMessage = firstMessage;
        this.firstMessageInterruptionsEnabled = firstMessageInterruptionsEnabled;
        this.firstMessageMode = firstMessageMode;
        this.voicemailDetection = voicemailDetection;
        this.clientMessages = clientMessages;
        this.serverMessages = serverMessages;
        this.silenceTimeoutSeconds = silenceTimeoutSeconds;
        this.maxDurationSeconds = maxDurationSeconds;
        this.backgroundSound = backgroundSound;
        this.backgroundDenoisingEnabled = backgroundDenoisingEnabled;
        this.modelOutputInMessagesEnabled = modelOutputInMessagesEnabled;
        this.transportConfigurations = transportConfigurations;
        this.observabilityPlan = observabilityPlan;
        this.credentials = credentials;
        this.name = name;
        this.voicemailMessage = voicemailMessage;
        this.endCallMessage = endCallMessage;
        this.endCallPhrases = endCallPhrases;
        this.compliancePlan = compliancePlan;
        this.metadata = metadata;
        this.analysisPlan = analysisPlan;
        this.artifactPlan = artifactPlan;
        this.messagePlan = messagePlan;
        this.startSpeakingPlan = startSpeakingPlan;
        this.stopSpeakingPlan = stopSpeakingPlan;
        this.monitorPlan = monitorPlan;
        this.credentialIds = credentialIds;
        this.server = server;
        this.hooks = hooks;
        this.keypadInputPlan = keypadInputPlan;
        this.id = id;
        this.orgId = orgId;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return These are the options for the assistant's transcriber.
     */
    @JsonProperty("transcriber")
    public Optional<AssistantTranscriber> getTranscriber() {
        return transcriber;
    }

    /**
     * @return These are the options for the assistant's LLM.
     */
    @JsonProperty("model")
    public Optional<AssistantModel> getModel() {
        return model;
    }

    /**
     * @return These are the options for the assistant's voice.
     */
    @JsonProperty("voice")
    public Optional<AssistantVoice> getVoice() {
        return voice;
    }

    /**
     * @return This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
     * <p>If unspecified, assistant will wait for user to speak and use the model to respond once they speak.</p>
     */
    @JsonProperty("firstMessage")
    public Optional<String> getFirstMessage() {
        return firstMessage;
    }

    @JsonProperty("firstMessageInterruptionsEnabled")
    public Optional<Boolean> getFirstMessageInterruptionsEnabled() {
        return firstMessageInterruptionsEnabled;
    }

    /**
     * @return This is the mode for the first message. Default is 'assistant-speaks-first'.
     * <p>Use:</p>
     * <ul>
     * <li>'assistant-speaks-first' to have the assistant speak first.</li>
     * <li>'assistant-waits-for-user' to have the assistant wait for the user to speak first.</li>
     * <li>'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (<code>assistant.model.messages</code> at call start, <code>call.messages</code> at squad transfer points).</li>
     * </ul>
     * <p>@default 'assistant-speaks-first'</p>
     */
    @JsonProperty("firstMessageMode")
    public Optional<AssistantFirstMessageMode> getFirstMessageMode() {
        return firstMessageMode;
    }

    /**
     * @return These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
     * This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
     * You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
     */
    @JsonProperty("voicemailDetection")
    public Optional<AssistantVoicemailDetection> getVoicemailDetection() {
        return voicemailDetection;
    }

    /**
     * @return These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.
     */
    @JsonProperty("clientMessages")
    public Optional<List<AssistantClientMessagesItem>> getClientMessages() {
        return clientMessages;
    }

    /**
     * @return These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
     */
    @JsonProperty("serverMessages")
    public Optional<List<AssistantServerMessagesItem>> getServerMessages() {
        return serverMessages;
    }

    /**
     * @return How many seconds of silence to wait before ending the call. Defaults to 30.
     * <p>@default 30</p>
     */
    @JsonProperty("silenceTimeoutSeconds")
    public Optional<Double> getSilenceTimeoutSeconds() {
        return silenceTimeoutSeconds;
    }

    /**
     * @return This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
     * <p>@default 600 (10 minutes)</p>
     */
    @JsonProperty("maxDurationSeconds")
    public Optional<Double> getMaxDurationSeconds() {
        return maxDurationSeconds;
    }

    /**
     * @return This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
     * You can also provide a custom sound by providing a URL to an audio file.
     */
    @JsonProperty("backgroundSound")
    public Optional<AssistantBackgroundSound> getBackgroundSound() {
        return backgroundSound;
    }

    /**
     * @return This enables filtering of noise and background speech while the user is talking.
     * <p>Default <code>false</code> while in beta.</p>
     * <p>@default false</p>
     */
    @JsonProperty("backgroundDenoisingEnabled")
    public Optional<Boolean> getBackgroundDenoisingEnabled() {
        return backgroundDenoisingEnabled;
    }

    /**
     * @return This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
     * <p>Default <code>false</code> while in beta.</p>
     * <p>@default false</p>
     */
    @JsonProperty("modelOutputInMessagesEnabled")
    public Optional<Boolean> getModelOutputInMessagesEnabled() {
        return modelOutputInMessagesEnabled;
    }

    /**
     * @return These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
     */
    @JsonProperty("transportConfigurations")
    public Optional<List<TransportConfigurationTwilio>> getTransportConfigurations() {
        return transportConfigurations;
    }

    /**
     * @return This is the plan for observability configuration of assistant's calls.
     * Currently supports Langfuse for tracing and monitoring.
     */
    @JsonProperty("observabilityPlan")
    public Optional<LangfuseObservabilityPlan> getObservabilityPlan() {
        return observabilityPlan;
    }

    /**
     * @return These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.
     */
    @JsonProperty("credentials")
    public Optional<List<AssistantCredentialsItem>> getCredentials() {
        return credentials;
    }

    /**
     * @return This is the name of the assistant.
     * <p>This is required when you want to transfer between assistants in a call.</p>
     */
    @JsonProperty("name")
    public Optional<String> getName() {
        return name;
    }

    /**
     * @return This is the message that the assistant will say if the call is forwarded to voicemail.
     * <p>If unspecified, it will hang up.</p>
     */
    @JsonProperty("voicemailMessage")
    public Optional<String> getVoicemailMessage() {
        return voicemailMessage;
    }

    /**
     * @return This is the message that the assistant will say if it ends the call.
     * <p>If unspecified, it will hang up without saying anything.</p>
     */
    @JsonProperty("endCallMessage")
    public Optional<String> getEndCallMessage() {
        return endCallMessage;
    }

    /**
     * @return This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
     */
    @JsonProperty("endCallPhrases")
    public Optional<List<String>> getEndCallPhrases() {
        return endCallPhrases;
    }

    @JsonProperty("compliancePlan")
    public Optional<CompliancePlan> getCompliancePlan() {
        return compliancePlan;
    }

    /**
     * @return This is for metadata you want to store on the assistant.
     */
    @JsonProperty("metadata")
    public Optional<Map<String, Object>> getMetadata() {
        return metadata;
    }

    /**
     * @return This is the plan for analysis of assistant's calls. Stored in <code>call.analysis</code>.
     */
    @JsonProperty("analysisPlan")
    public Optional<AnalysisPlan> getAnalysisPlan() {
        return analysisPlan;
    }

    /**
     * @return This is the plan for artifacts generated during assistant's calls. Stored in <code>call.artifact</code>.
     * <p>Note: <code>recordingEnabled</code> is currently at the root level. It will be moved to <code>artifactPlan</code> in the future, but will remain backwards compatible.</p>
     */
    @JsonProperty("artifactPlan")
    public Optional<ArtifactPlan> getArtifactPlan() {
        return artifactPlan;
    }

    /**
     * @return This is the plan for static predefined messages that can be spoken by the assistant during the call, like <code>idleMessages</code>.
     * <p>Note: <code>firstMessage</code>, <code>voicemailMessage</code>, and <code>endCallMessage</code> are currently at the root level. They will be moved to <code>messagePlan</code> in the future, but will remain backwards compatible.</p>
     */
    @JsonProperty("messagePlan")
    public Optional<MessagePlan> getMessagePlan() {
        return messagePlan;
    }

    /**
     * @return This is the plan for when the assistant should start talking.
     * <p>You should configure this if you're running into these issues:</p>
     * <ul>
     * <li>The assistant is too slow to start talking after the customer is done speaking.</li>
     * <li>The assistant is too fast to start talking after the customer is done speaking.</li>
     * <li>The assistant is so fast that it's actually interrupting the customer.</li>
     * </ul>
     */
    @JsonProperty("startSpeakingPlan")
    public Optional<StartSpeakingPlan> getStartSpeakingPlan() {
        return startSpeakingPlan;
    }

    /**
     * @return This is the plan for when assistant should stop talking on customer interruption.
     * <p>You should configure this if you're running into these issues:</p>
     * <ul>
     * <li>The assistant is too slow to recognize customer's interruption.</li>
     * <li>The assistant is too fast to recognize customer's interruption.</li>
     * <li>The assistant is getting interrupted by phrases that are just acknowledgments.</li>
     * <li>The assistant is getting interrupted by background noises.</li>
     * <li>The assistant is not properly stopping -- it starts talking right after getting interrupted.</li>
     * </ul>
     */
    @JsonProperty("stopSpeakingPlan")
    public Optional<StopSpeakingPlan> getStopSpeakingPlan() {
        return stopSpeakingPlan;
    }

    /**
     * @return This is the plan for real-time monitoring of the assistant's calls.
     * <p>Usage:</p>
     * <ul>
     * <li>To enable live listening of the assistant's calls, set <code>monitorPlan.listenEnabled</code> to <code>true</code>.</li>
     * <li>To enable live control of the assistant's calls, set <code>monitorPlan.controlEnabled</code> to <code>true</code>.</li>
     * </ul>
     * <p>Note, <code>serverMessages</code>, <code>clientMessages</code>, <code>serverUrl</code> and <code>serverUrlSecret</code> are currently at the root level but will be moved to <code>monitorPlan</code> in the future. Will remain backwards compatible</p>
     */
    @JsonProperty("monitorPlan")
    public Optional<MonitorPlan> getMonitorPlan() {
        return monitorPlan;
    }

    /**
     * @return These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
     */
    @JsonProperty("credentialIds")
    public Optional<List<String>> getCredentialIds() {
        return credentialIds;
    }

    /**
     * @return This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
     * <p>The order of precedence is:</p>
     * <ol>
     * <li>assistant.server.url</li>
     * <li>phoneNumber.serverUrl</li>
     * <li>org.serverUrl</li>
     * </ol>
     */
    @JsonProperty("server")
    public Optional<Server> getServer() {
        return server;
    }

    /**
     * @return This is a set of actions that will be performed on certain events.
     */
    @JsonProperty("hooks")
    public Optional<List<AssistantHooks>> getHooks() {
        return hooks;
    }

    @JsonProperty("keypadInputPlan")
    public Optional<KeypadInputPlan> getKeypadInputPlan() {
        return keypadInputPlan;
    }

    /**
     * @return This is the unique identifier for the assistant.
     */
    @JsonProperty("id")
    public String getId() {
        return id;
    }

    /**
     * @return This is the unique identifier for the org that this assistant belongs to.
     */
    @JsonProperty("orgId")
    public String getOrgId() {
        return orgId;
    }

    /**
     * @return This is the ISO 8601 date-time string of when the assistant was created.
     */
    @JsonProperty("createdAt")
    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    /**
     * @return This is the ISO 8601 date-time string of when the assistant was last updated.
     */
    @JsonProperty("updatedAt")
    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof Assistant && equalTo((Assistant) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(Assistant other) {
        return transcriber.equals(other.transcriber)
                && model.equals(other.model)
                && voice.equals(other.voice)
                && firstMessage.equals(other.firstMessage)
                && firstMessageInterruptionsEnabled.equals(other.firstMessageInterruptionsEnabled)
                && firstMessageMode.equals(other.firstMessageMode)
                && voicemailDetection.equals(other.voicemailDetection)
                && clientMessages.equals(other.clientMessages)
                && serverMessages.equals(other.serverMessages)
                && silenceTimeoutSeconds.equals(other.silenceTimeoutSeconds)
                && maxDurationSeconds.equals(other.maxDurationSeconds)
                && backgroundSound.equals(other.backgroundSound)
                && backgroundDenoisingEnabled.equals(other.backgroundDenoisingEnabled)
                && modelOutputInMessagesEnabled.equals(other.modelOutputInMessagesEnabled)
                && transportConfigurations.equals(other.transportConfigurations)
                && observabilityPlan.equals(other.observabilityPlan)
                && credentials.equals(other.credentials)
                && name.equals(other.name)
                && voicemailMessage.equals(other.voicemailMessage)
                && endCallMessage.equals(other.endCallMessage)
                && endCallPhrases.equals(other.endCallPhrases)
                && compliancePlan.equals(other.compliancePlan)
                && metadata.equals(other.metadata)
                && analysisPlan.equals(other.analysisPlan)
                && artifactPlan.equals(other.artifactPlan)
                && messagePlan.equals(other.messagePlan)
                && startSpeakingPlan.equals(other.startSpeakingPlan)
                && stopSpeakingPlan.equals(other.stopSpeakingPlan)
                && monitorPlan.equals(other.monitorPlan)
                && credentialIds.equals(other.credentialIds)
                && server.equals(other.server)
                && hooks.equals(other.hooks)
                && keypadInputPlan.equals(other.keypadInputPlan)
                && id.equals(other.id)
                && orgId.equals(other.orgId)
                && createdAt.equals(other.createdAt)
                && updatedAt.equals(other.updatedAt);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.transcriber,
                this.model,
                this.voice,
                this.firstMessage,
                this.firstMessageInterruptionsEnabled,
                this.firstMessageMode,
                this.voicemailDetection,
                this.clientMessages,
                this.serverMessages,
                this.silenceTimeoutSeconds,
                this.maxDurationSeconds,
                this.backgroundSound,
                this.backgroundDenoisingEnabled,
                this.modelOutputInMessagesEnabled,
                this.transportConfigurations,
                this.observabilityPlan,
                this.credentials,
                this.name,
                this.voicemailMessage,
                this.endCallMessage,
                this.endCallPhrases,
                this.compliancePlan,
                this.metadata,
                this.analysisPlan,
                this.artifactPlan,
                this.messagePlan,
                this.startSpeakingPlan,
                this.stopSpeakingPlan,
                this.monitorPlan,
                this.credentialIds,
                this.server,
                this.hooks,
                this.keypadInputPlan,
                this.id,
                this.orgId,
                this.createdAt,
                this.updatedAt);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static IdStage builder() {
        return new Builder();
    }

    public interface IdStage {
        OrgIdStage id(@NotNull String id);

        Builder from(Assistant other);
    }

    public interface OrgIdStage {
        CreatedAtStage orgId(@NotNull String orgId);
    }

    public interface CreatedAtStage {
        UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt);
    }

    public interface UpdatedAtStage {
        _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt);
    }

    public interface _FinalStage {
        Assistant build();

        _FinalStage transcriber(Optional<AssistantTranscriber> transcriber);

        _FinalStage transcriber(AssistantTranscriber transcriber);

        _FinalStage model(Optional<AssistantModel> model);

        _FinalStage model(AssistantModel model);

        _FinalStage voice(Optional<AssistantVoice> voice);

        _FinalStage voice(AssistantVoice voice);

        _FinalStage firstMessage(Optional<String> firstMessage);

        _FinalStage firstMessage(String firstMessage);

        _FinalStage firstMessageInterruptionsEnabled(Optional<Boolean> firstMessageInterruptionsEnabled);

        _FinalStage firstMessageInterruptionsEnabled(Boolean firstMessageInterruptionsEnabled);

        _FinalStage firstMessageMode(Optional<AssistantFirstMessageMode> firstMessageMode);

        _FinalStage firstMessageMode(AssistantFirstMessageMode firstMessageMode);

        _FinalStage voicemailDetection(Optional<AssistantVoicemailDetection> voicemailDetection);

        _FinalStage voicemailDetection(AssistantVoicemailDetection voicemailDetection);

        _FinalStage clientMessages(Optional<List<AssistantClientMessagesItem>> clientMessages);

        _FinalStage clientMessages(List<AssistantClientMessagesItem> clientMessages);

        _FinalStage serverMessages(Optional<List<AssistantServerMessagesItem>> serverMessages);

        _FinalStage serverMessages(List<AssistantServerMessagesItem> serverMessages);

        _FinalStage silenceTimeoutSeconds(Optional<Double> silenceTimeoutSeconds);

        _FinalStage silenceTimeoutSeconds(Double silenceTimeoutSeconds);

        _FinalStage maxDurationSeconds(Optional<Double> maxDurationSeconds);

        _FinalStage maxDurationSeconds(Double maxDurationSeconds);

        _FinalStage backgroundSound(Optional<AssistantBackgroundSound> backgroundSound);

        _FinalStage backgroundSound(AssistantBackgroundSound backgroundSound);

        _FinalStage backgroundDenoisingEnabled(Optional<Boolean> backgroundDenoisingEnabled);

        _FinalStage backgroundDenoisingEnabled(Boolean backgroundDenoisingEnabled);

        _FinalStage modelOutputInMessagesEnabled(Optional<Boolean> modelOutputInMessagesEnabled);

        _FinalStage modelOutputInMessagesEnabled(Boolean modelOutputInMessagesEnabled);

        _FinalStage transportConfigurations(Optional<List<TransportConfigurationTwilio>> transportConfigurations);

        _FinalStage transportConfigurations(List<TransportConfigurationTwilio> transportConfigurations);

        _FinalStage observabilityPlan(Optional<LangfuseObservabilityPlan> observabilityPlan);

        _FinalStage observabilityPlan(LangfuseObservabilityPlan observabilityPlan);

        _FinalStage credentials(Optional<List<AssistantCredentialsItem>> credentials);

        _FinalStage credentials(List<AssistantCredentialsItem> credentials);

        _FinalStage name(Optional<String> name);

        _FinalStage name(String name);

        _FinalStage voicemailMessage(Optional<String> voicemailMessage);

        _FinalStage voicemailMessage(String voicemailMessage);

        _FinalStage endCallMessage(Optional<String> endCallMessage);

        _FinalStage endCallMessage(String endCallMessage);

        _FinalStage endCallPhrases(Optional<List<String>> endCallPhrases);

        _FinalStage endCallPhrases(List<String> endCallPhrases);

        _FinalStage compliancePlan(Optional<CompliancePlan> compliancePlan);

        _FinalStage compliancePlan(CompliancePlan compliancePlan);

        _FinalStage metadata(Optional<Map<String, Object>> metadata);

        _FinalStage metadata(Map<String, Object> metadata);

        _FinalStage analysisPlan(Optional<AnalysisPlan> analysisPlan);

        _FinalStage analysisPlan(AnalysisPlan analysisPlan);

        _FinalStage artifactPlan(Optional<ArtifactPlan> artifactPlan);

        _FinalStage artifactPlan(ArtifactPlan artifactPlan);

        _FinalStage messagePlan(Optional<MessagePlan> messagePlan);

        _FinalStage messagePlan(MessagePlan messagePlan);

        _FinalStage startSpeakingPlan(Optional<StartSpeakingPlan> startSpeakingPlan);

        _FinalStage startSpeakingPlan(StartSpeakingPlan startSpeakingPlan);

        _FinalStage stopSpeakingPlan(Optional<StopSpeakingPlan> stopSpeakingPlan);

        _FinalStage stopSpeakingPlan(StopSpeakingPlan stopSpeakingPlan);

        _FinalStage monitorPlan(Optional<MonitorPlan> monitorPlan);

        _FinalStage monitorPlan(MonitorPlan monitorPlan);

        _FinalStage credentialIds(Optional<List<String>> credentialIds);

        _FinalStage credentialIds(List<String> credentialIds);

        _FinalStage server(Optional<Server> server);

        _FinalStage server(Server server);

        _FinalStage hooks(Optional<List<AssistantHooks>> hooks);

        _FinalStage hooks(List<AssistantHooks> hooks);

        _FinalStage keypadInputPlan(Optional<KeypadInputPlan> keypadInputPlan);

        _FinalStage keypadInputPlan(KeypadInputPlan keypadInputPlan);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements IdStage, OrgIdStage, CreatedAtStage, UpdatedAtStage, _FinalStage {
        private String id;

        private String orgId;

        private OffsetDateTime createdAt;

        private OffsetDateTime updatedAt;

        private Optional<KeypadInputPlan> keypadInputPlan = Optional.empty();

        private Optional<List<AssistantHooks>> hooks = Optional.empty();

        private Optional<Server> server = Optional.empty();

        private Optional<List<String>> credentialIds = Optional.empty();

        private Optional<MonitorPlan> monitorPlan = Optional.empty();

        private Optional<StopSpeakingPlan> stopSpeakingPlan = Optional.empty();

        private Optional<StartSpeakingPlan> startSpeakingPlan = Optional.empty();

        private Optional<MessagePlan> messagePlan = Optional.empty();

        private Optional<ArtifactPlan> artifactPlan = Optional.empty();

        private Optional<AnalysisPlan> analysisPlan = Optional.empty();

        private Optional<Map<String, Object>> metadata = Optional.empty();

        private Optional<CompliancePlan> compliancePlan = Optional.empty();

        private Optional<List<String>> endCallPhrases = Optional.empty();

        private Optional<String> endCallMessage = Optional.empty();

        private Optional<String> voicemailMessage = Optional.empty();

        private Optional<String> name = Optional.empty();

        private Optional<List<AssistantCredentialsItem>> credentials = Optional.empty();

        private Optional<LangfuseObservabilityPlan> observabilityPlan = Optional.empty();

        private Optional<List<TransportConfigurationTwilio>> transportConfigurations = Optional.empty();

        private Optional<Boolean> modelOutputInMessagesEnabled = Optional.empty();

        private Optional<Boolean> backgroundDenoisingEnabled = Optional.empty();

        private Optional<AssistantBackgroundSound> backgroundSound = Optional.empty();

        private Optional<Double> maxDurationSeconds = Optional.empty();

        private Optional<Double> silenceTimeoutSeconds = Optional.empty();

        private Optional<List<AssistantServerMessagesItem>> serverMessages = Optional.empty();

        private Optional<List<AssistantClientMessagesItem>> clientMessages = Optional.empty();

        private Optional<AssistantVoicemailDetection> voicemailDetection = Optional.empty();

        private Optional<AssistantFirstMessageMode> firstMessageMode = Optional.empty();

        private Optional<Boolean> firstMessageInterruptionsEnabled = Optional.empty();

        private Optional<String> firstMessage = Optional.empty();

        private Optional<AssistantVoice> voice = Optional.empty();

        private Optional<AssistantModel> model = Optional.empty();

        private Optional<AssistantTranscriber> transcriber = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(Assistant other) {
            transcriber(other.getTranscriber());
            model(other.getModel());
            voice(other.getVoice());
            firstMessage(other.getFirstMessage());
            firstMessageInterruptionsEnabled(other.getFirstMessageInterruptionsEnabled());
            firstMessageMode(other.getFirstMessageMode());
            voicemailDetection(other.getVoicemailDetection());
            clientMessages(other.getClientMessages());
            serverMessages(other.getServerMessages());
            silenceTimeoutSeconds(other.getSilenceTimeoutSeconds());
            maxDurationSeconds(other.getMaxDurationSeconds());
            backgroundSound(other.getBackgroundSound());
            backgroundDenoisingEnabled(other.getBackgroundDenoisingEnabled());
            modelOutputInMessagesEnabled(other.getModelOutputInMessagesEnabled());
            transportConfigurations(other.getTransportConfigurations());
            observabilityPlan(other.getObservabilityPlan());
            credentials(other.getCredentials());
            name(other.getName());
            voicemailMessage(other.getVoicemailMessage());
            endCallMessage(other.getEndCallMessage());
            endCallPhrases(other.getEndCallPhrases());
            compliancePlan(other.getCompliancePlan());
            metadata(other.getMetadata());
            analysisPlan(other.getAnalysisPlan());
            artifactPlan(other.getArtifactPlan());
            messagePlan(other.getMessagePlan());
            startSpeakingPlan(other.getStartSpeakingPlan());
            stopSpeakingPlan(other.getStopSpeakingPlan());
            monitorPlan(other.getMonitorPlan());
            credentialIds(other.getCredentialIds());
            server(other.getServer());
            hooks(other.getHooks());
            keypadInputPlan(other.getKeypadInputPlan());
            id(other.getId());
            orgId(other.getOrgId());
            createdAt(other.getCreatedAt());
            updatedAt(other.getUpdatedAt());
            return this;
        }

        /**
         * <p>This is the unique identifier for the assistant.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("id")
        public OrgIdStage id(@NotNull String id) {
            this.id = Objects.requireNonNull(id, "id must not be null");
            return this;
        }

        /**
         * <p>This is the unique identifier for the org that this assistant belongs to.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("orgId")
        public CreatedAtStage orgId(@NotNull String orgId) {
            this.orgId = Objects.requireNonNull(orgId, "orgId must not be null");
            return this;
        }

        /**
         * <p>This is the ISO 8601 date-time string of when the assistant was created.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("createdAt")
        public UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt) {
            this.createdAt = Objects.requireNonNull(createdAt, "createdAt must not be null");
            return this;
        }

        /**
         * <p>This is the ISO 8601 date-time string of when the assistant was last updated.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("updatedAt")
        public _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt) {
            this.updatedAt = Objects.requireNonNull(updatedAt, "updatedAt must not be null");
            return this;
        }

        @java.lang.Override
        public _FinalStage keypadInputPlan(KeypadInputPlan keypadInputPlan) {
            this.keypadInputPlan = Optional.ofNullable(keypadInputPlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "keypadInputPlan", nulls = Nulls.SKIP)
        public _FinalStage keypadInputPlan(Optional<KeypadInputPlan> keypadInputPlan) {
            this.keypadInputPlan = keypadInputPlan;
            return this;
        }

        /**
         * <p>This is a set of actions that will be performed on certain events.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage hooks(List<AssistantHooks> hooks) {
            this.hooks = Optional.ofNullable(hooks);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "hooks", nulls = Nulls.SKIP)
        public _FinalStage hooks(Optional<List<AssistantHooks>> hooks) {
            this.hooks = hooks;
            return this;
        }

        /**
         * <p>This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.</p>
         * <p>The order of precedence is:</p>
         * <ol>
         * <li>assistant.server.url</li>
         * <li>phoneNumber.serverUrl</li>
         * <li>org.serverUrl</li>
         * </ol>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage server(Server server) {
            this.server = Optional.ofNullable(server);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "server", nulls = Nulls.SKIP)
        public _FinalStage server(Optional<Server> server) {
            this.server = server;
            return this;
        }

        /**
         * <p>These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage credentialIds(List<String> credentialIds) {
            this.credentialIds = Optional.ofNullable(credentialIds);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "credentialIds", nulls = Nulls.SKIP)
        public _FinalStage credentialIds(Optional<List<String>> credentialIds) {
            this.credentialIds = credentialIds;
            return this;
        }

        /**
         * <p>This is the plan for real-time monitoring of the assistant's calls.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To enable live listening of the assistant's calls, set <code>monitorPlan.listenEnabled</code> to <code>true</code>.</li>
         * <li>To enable live control of the assistant's calls, set <code>monitorPlan.controlEnabled</code> to <code>true</code>.</li>
         * </ul>
         * <p>Note, <code>serverMessages</code>, <code>clientMessages</code>, <code>serverUrl</code> and <code>serverUrlSecret</code> are currently at the root level but will be moved to <code>monitorPlan</code> in the future. Will remain backwards compatible</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage monitorPlan(MonitorPlan monitorPlan) {
            this.monitorPlan = Optional.ofNullable(monitorPlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "monitorPlan", nulls = Nulls.SKIP)
        public _FinalStage monitorPlan(Optional<MonitorPlan> monitorPlan) {
            this.monitorPlan = monitorPlan;
            return this;
        }

        /**
         * <p>This is the plan for when assistant should stop talking on customer interruption.</p>
         * <p>You should configure this if you're running into these issues:</p>
         * <ul>
         * <li>The assistant is too slow to recognize customer's interruption.</li>
         * <li>The assistant is too fast to recognize customer's interruption.</li>
         * <li>The assistant is getting interrupted by phrases that are just acknowledgments.</li>
         * <li>The assistant is getting interrupted by background noises.</li>
         * <li>The assistant is not properly stopping -- it starts talking right after getting interrupted.</li>
         * </ul>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage stopSpeakingPlan(StopSpeakingPlan stopSpeakingPlan) {
            this.stopSpeakingPlan = Optional.ofNullable(stopSpeakingPlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "stopSpeakingPlan", nulls = Nulls.SKIP)
        public _FinalStage stopSpeakingPlan(Optional<StopSpeakingPlan> stopSpeakingPlan) {
            this.stopSpeakingPlan = stopSpeakingPlan;
            return this;
        }

        /**
         * <p>This is the plan for when the assistant should start talking.</p>
         * <p>You should configure this if you're running into these issues:</p>
         * <ul>
         * <li>The assistant is too slow to start talking after the customer is done speaking.</li>
         * <li>The assistant is too fast to start talking after the customer is done speaking.</li>
         * <li>The assistant is so fast that it's actually interrupting the customer.</li>
         * </ul>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage startSpeakingPlan(StartSpeakingPlan startSpeakingPlan) {
            this.startSpeakingPlan = Optional.ofNullable(startSpeakingPlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "startSpeakingPlan", nulls = Nulls.SKIP)
        public _FinalStage startSpeakingPlan(Optional<StartSpeakingPlan> startSpeakingPlan) {
            this.startSpeakingPlan = startSpeakingPlan;
            return this;
        }

        /**
         * <p>This is the plan for static predefined messages that can be spoken by the assistant during the call, like <code>idleMessages</code>.</p>
         * <p>Note: <code>firstMessage</code>, <code>voicemailMessage</code>, and <code>endCallMessage</code> are currently at the root level. They will be moved to <code>messagePlan</code> in the future, but will remain backwards compatible.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage messagePlan(MessagePlan messagePlan) {
            this.messagePlan = Optional.ofNullable(messagePlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "messagePlan", nulls = Nulls.SKIP)
        public _FinalStage messagePlan(Optional<MessagePlan> messagePlan) {
            this.messagePlan = messagePlan;
            return this;
        }

        /**
         * <p>This is the plan for artifacts generated during assistant's calls. Stored in <code>call.artifact</code>.</p>
         * <p>Note: <code>recordingEnabled</code> is currently at the root level. It will be moved to <code>artifactPlan</code> in the future, but will remain backwards compatible.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage artifactPlan(ArtifactPlan artifactPlan) {
            this.artifactPlan = Optional.ofNullable(artifactPlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "artifactPlan", nulls = Nulls.SKIP)
        public _FinalStage artifactPlan(Optional<ArtifactPlan> artifactPlan) {
            this.artifactPlan = artifactPlan;
            return this;
        }

        /**
         * <p>This is the plan for analysis of assistant's calls. Stored in <code>call.analysis</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage analysisPlan(AnalysisPlan analysisPlan) {
            this.analysisPlan = Optional.ofNullable(analysisPlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "analysisPlan", nulls = Nulls.SKIP)
        public _FinalStage analysisPlan(Optional<AnalysisPlan> analysisPlan) {
            this.analysisPlan = analysisPlan;
            return this;
        }

        /**
         * <p>This is for metadata you want to store on the assistant.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage metadata(Map<String, Object> metadata) {
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "metadata", nulls = Nulls.SKIP)
        public _FinalStage metadata(Optional<Map<String, Object>> metadata) {
            this.metadata = metadata;
            return this;
        }

        @java.lang.Override
        public _FinalStage compliancePlan(CompliancePlan compliancePlan) {
            this.compliancePlan = Optional.ofNullable(compliancePlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "compliancePlan", nulls = Nulls.SKIP)
        public _FinalStage compliancePlan(Optional<CompliancePlan> compliancePlan) {
            this.compliancePlan = compliancePlan;
            return this;
        }

        /**
         * <p>This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage endCallPhrases(List<String> endCallPhrases) {
            this.endCallPhrases = Optional.ofNullable(endCallPhrases);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "endCallPhrases", nulls = Nulls.SKIP)
        public _FinalStage endCallPhrases(Optional<List<String>> endCallPhrases) {
            this.endCallPhrases = endCallPhrases;
            return this;
        }

        /**
         * <p>This is the message that the assistant will say if it ends the call.</p>
         * <p>If unspecified, it will hang up without saying anything.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage endCallMessage(String endCallMessage) {
            this.endCallMessage = Optional.ofNullable(endCallMessage);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "endCallMessage", nulls = Nulls.SKIP)
        public _FinalStage endCallMessage(Optional<String> endCallMessage) {
            this.endCallMessage = endCallMessage;
            return this;
        }

        /**
         * <p>This is the message that the assistant will say if the call is forwarded to voicemail.</p>
         * <p>If unspecified, it will hang up.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage voicemailMessage(String voicemailMessage) {
            this.voicemailMessage = Optional.ofNullable(voicemailMessage);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "voicemailMessage", nulls = Nulls.SKIP)
        public _FinalStage voicemailMessage(Optional<String> voicemailMessage) {
            this.voicemailMessage = voicemailMessage;
            return this;
        }

        /**
         * <p>This is the name of the assistant.</p>
         * <p>This is required when you want to transfer between assistants in a call.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage name(String name) {
            this.name = Optional.ofNullable(name);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "name", nulls = Nulls.SKIP)
        public _FinalStage name(Optional<String> name) {
            this.name = name;
            return this;
        }

        /**
         * <p>These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage credentials(List<AssistantCredentialsItem> credentials) {
            this.credentials = Optional.ofNullable(credentials);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "credentials", nulls = Nulls.SKIP)
        public _FinalStage credentials(Optional<List<AssistantCredentialsItem>> credentials) {
            this.credentials = credentials;
            return this;
        }

        /**
         * <p>This is the plan for observability configuration of assistant's calls.
         * Currently supports Langfuse for tracing and monitoring.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage observabilityPlan(LangfuseObservabilityPlan observabilityPlan) {
            this.observabilityPlan = Optional.ofNullable(observabilityPlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "observabilityPlan", nulls = Nulls.SKIP)
        public _FinalStage observabilityPlan(Optional<LangfuseObservabilityPlan> observabilityPlan) {
            this.observabilityPlan = observabilityPlan;
            return this;
        }

        /**
         * <p>These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage transportConfigurations(List<TransportConfigurationTwilio> transportConfigurations) {
            this.transportConfigurations = Optional.ofNullable(transportConfigurations);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "transportConfigurations", nulls = Nulls.SKIP)
        public _FinalStage transportConfigurations(
                Optional<List<TransportConfigurationTwilio>> transportConfigurations) {
            this.transportConfigurations = transportConfigurations;
            return this;
        }

        /**
         * <p>This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.</p>
         * <p>Default <code>false</code> while in beta.</p>
         * <p>@default false</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage modelOutputInMessagesEnabled(Boolean modelOutputInMessagesEnabled) {
            this.modelOutputInMessagesEnabled = Optional.ofNullable(modelOutputInMessagesEnabled);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "modelOutputInMessagesEnabled", nulls = Nulls.SKIP)
        public _FinalStage modelOutputInMessagesEnabled(Optional<Boolean> modelOutputInMessagesEnabled) {
            this.modelOutputInMessagesEnabled = modelOutputInMessagesEnabled;
            return this;
        }

        /**
         * <p>This enables filtering of noise and background speech while the user is talking.</p>
         * <p>Default <code>false</code> while in beta.</p>
         * <p>@default false</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage backgroundDenoisingEnabled(Boolean backgroundDenoisingEnabled) {
            this.backgroundDenoisingEnabled = Optional.ofNullable(backgroundDenoisingEnabled);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "backgroundDenoisingEnabled", nulls = Nulls.SKIP)
        public _FinalStage backgroundDenoisingEnabled(Optional<Boolean> backgroundDenoisingEnabled) {
            this.backgroundDenoisingEnabled = backgroundDenoisingEnabled;
            return this;
        }

        /**
         * <p>This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
         * You can also provide a custom sound by providing a URL to an audio file.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage backgroundSound(AssistantBackgroundSound backgroundSound) {
            this.backgroundSound = Optional.ofNullable(backgroundSound);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "backgroundSound", nulls = Nulls.SKIP)
        public _FinalStage backgroundSound(Optional<AssistantBackgroundSound> backgroundSound) {
            this.backgroundSound = backgroundSound;
            return this;
        }

        /**
         * <p>This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.</p>
         * <p>@default 600 (10 minutes)</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage maxDurationSeconds(Double maxDurationSeconds) {
            this.maxDurationSeconds = Optional.ofNullable(maxDurationSeconds);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "maxDurationSeconds", nulls = Nulls.SKIP)
        public _FinalStage maxDurationSeconds(Optional<Double> maxDurationSeconds) {
            this.maxDurationSeconds = maxDurationSeconds;
            return this;
        }

        /**
         * <p>How many seconds of silence to wait before ending the call. Defaults to 30.</p>
         * <p>@default 30</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage silenceTimeoutSeconds(Double silenceTimeoutSeconds) {
            this.silenceTimeoutSeconds = Optional.ofNullable(silenceTimeoutSeconds);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "silenceTimeoutSeconds", nulls = Nulls.SKIP)
        public _FinalStage silenceTimeoutSeconds(Optional<Double> silenceTimeoutSeconds) {
            this.silenceTimeoutSeconds = silenceTimeoutSeconds;
            return this;
        }

        /**
         * <p>These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage serverMessages(List<AssistantServerMessagesItem> serverMessages) {
            this.serverMessages = Optional.ofNullable(serverMessages);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "serverMessages", nulls = Nulls.SKIP)
        public _FinalStage serverMessages(Optional<List<AssistantServerMessagesItem>> serverMessages) {
            this.serverMessages = serverMessages;
            return this;
        }

        /**
         * <p>These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage clientMessages(List<AssistantClientMessagesItem> clientMessages) {
            this.clientMessages = Optional.ofNullable(clientMessages);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "clientMessages", nulls = Nulls.SKIP)
        public _FinalStage clientMessages(Optional<List<AssistantClientMessagesItem>> clientMessages) {
            this.clientMessages = clientMessages;
            return this;
        }

        /**
         * <p>These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
         * This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
         * You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage voicemailDetection(AssistantVoicemailDetection voicemailDetection) {
            this.voicemailDetection = Optional.ofNullable(voicemailDetection);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "voicemailDetection", nulls = Nulls.SKIP)
        public _FinalStage voicemailDetection(Optional<AssistantVoicemailDetection> voicemailDetection) {
            this.voicemailDetection = voicemailDetection;
            return this;
        }

        /**
         * <p>This is the mode for the first message. Default is 'assistant-speaks-first'.</p>
         * <p>Use:</p>
         * <ul>
         * <li>'assistant-speaks-first' to have the assistant speak first.</li>
         * <li>'assistant-waits-for-user' to have the assistant wait for the user to speak first.</li>
         * <li>'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (<code>assistant.model.messages</code> at call start, <code>call.messages</code> at squad transfer points).</li>
         * </ul>
         * <p>@default 'assistant-speaks-first'</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage firstMessageMode(AssistantFirstMessageMode firstMessageMode) {
            this.firstMessageMode = Optional.ofNullable(firstMessageMode);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "firstMessageMode", nulls = Nulls.SKIP)
        public _FinalStage firstMessageMode(Optional<AssistantFirstMessageMode> firstMessageMode) {
            this.firstMessageMode = firstMessageMode;
            return this;
        }

        @java.lang.Override
        public _FinalStage firstMessageInterruptionsEnabled(Boolean firstMessageInterruptionsEnabled) {
            this.firstMessageInterruptionsEnabled = Optional.ofNullable(firstMessageInterruptionsEnabled);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "firstMessageInterruptionsEnabled", nulls = Nulls.SKIP)
        public _FinalStage firstMessageInterruptionsEnabled(Optional<Boolean> firstMessageInterruptionsEnabled) {
            this.firstMessageInterruptionsEnabled = firstMessageInterruptionsEnabled;
            return this;
        }

        /**
         * <p>This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).</p>
         * <p>If unspecified, assistant will wait for user to speak and use the model to respond once they speak.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage firstMessage(String firstMessage) {
            this.firstMessage = Optional.ofNullable(firstMessage);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "firstMessage", nulls = Nulls.SKIP)
        public _FinalStage firstMessage(Optional<String> firstMessage) {
            this.firstMessage = firstMessage;
            return this;
        }

        /**
         * <p>These are the options for the assistant's voice.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage voice(AssistantVoice voice) {
            this.voice = Optional.ofNullable(voice);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "voice", nulls = Nulls.SKIP)
        public _FinalStage voice(Optional<AssistantVoice> voice) {
            this.voice = voice;
            return this;
        }

        /**
         * <p>These are the options for the assistant's LLM.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage model(AssistantModel model) {
            this.model = Optional.ofNullable(model);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "model", nulls = Nulls.SKIP)
        public _FinalStage model(Optional<AssistantModel> model) {
            this.model = model;
            return this;
        }

        /**
         * <p>These are the options for the assistant's transcriber.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage transcriber(AssistantTranscriber transcriber) {
            this.transcriber = Optional.ofNullable(transcriber);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "transcriber", nulls = Nulls.SKIP)
        public _FinalStage transcriber(Optional<AssistantTranscriber> transcriber) {
            this.transcriber = transcriber;
            return this;
        }

        @java.lang.Override
        public Assistant build() {
            return new Assistant(
                    transcriber,
                    model,
                    voice,
                    firstMessage,
                    firstMessageInterruptionsEnabled,
                    firstMessageMode,
                    voicemailDetection,
                    clientMessages,
                    serverMessages,
                    silenceTimeoutSeconds,
                    maxDurationSeconds,
                    backgroundSound,
                    backgroundDenoisingEnabled,
                    modelOutputInMessagesEnabled,
                    transportConfigurations,
                    observabilityPlan,
                    credentials,
                    name,
                    voicemailMessage,
                    endCallMessage,
                    endCallPhrases,
                    compliancePlan,
                    metadata,
                    analysisPlan,
                    artifactPlan,
                    messagePlan,
                    startSpeakingPlan,
                    stopSpeakingPlan,
                    monitorPlan,
                    credentialIds,
                    server,
                    hooks,
                    keypadInputPlan,
                    id,
                    orgId,
                    createdAt,
                    updatedAt,
                    additionalProperties);
        }
    }
}
