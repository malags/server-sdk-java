/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ChunkPlan.Builder.class)
public final class ChunkPlan {
    private final Optional<Boolean> enabled;

    private final Optional<Double> minCharacters;

    private final Optional<List<PunctuationBoundary>> punctuationBoundaries;

    private final Optional<FormatPlan> formatPlan;

    private final Map<String, Object> additionalProperties;

    private ChunkPlan(
            Optional<Boolean> enabled,
            Optional<Double> minCharacters,
            Optional<List<PunctuationBoundary>> punctuationBoundaries,
            Optional<FormatPlan> formatPlan,
            Map<String, Object> additionalProperties) {
        this.enabled = enabled;
        this.minCharacters = minCharacters;
        this.punctuationBoundaries = punctuationBoundaries;
        this.formatPlan = formatPlan;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return This determines whether the model output is chunked before being sent to the voice provider. Default <code>true</code>.
     * <p>Usage:</p>
     * <ul>
     * <li>To rely on the voice provider's audio generation logic, set this to <code>false</code>.</li>
     * <li>If seeing issues with quality, set this to <code>true</code>.</li>
     * </ul>
     * <p>If disabled, Vapi-provided audio control tokens like &lt;flush /&gt; will not work.</p>
     * <p>@default true</p>
     */
    @JsonProperty("enabled")
    public Optional<Boolean> getEnabled() {
        return enabled;
    }

    /**
     * @return This is the minimum number of characters in a chunk.
     * <p>Usage:</p>
     * <ul>
     * <li>To increase quality, set this to a higher value.</li>
     * <li>To decrease latency, set this to a lower value.</li>
     * </ul>
     * <p>@default 30</p>
     */
    @JsonProperty("minCharacters")
    public Optional<Double> getMinCharacters() {
        return minCharacters;
    }

    /**
     * @return These are the punctuations that are considered valid boundaries for a chunk to be created.
     * <p>Usage:</p>
     * <ul>
     * <li>To increase quality, constrain to fewer boundaries.</li>
     * <li>To decrease latency, enable all.</li>
     * </ul>
     * <p>Default is automatically set to balance the trade-off between quality and latency based on the provider.</p>
     */
    @JsonProperty("punctuationBoundaries")
    public Optional<List<PunctuationBoundary>> getPunctuationBoundaries() {
        return punctuationBoundaries;
    }

    /**
     * @return This is the plan for formatting the chunk before it is sent to the voice provider.
     */
    @JsonProperty("formatPlan")
    public Optional<FormatPlan> getFormatPlan() {
        return formatPlan;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ChunkPlan && equalTo((ChunkPlan) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ChunkPlan other) {
        return enabled.equals(other.enabled)
                && minCharacters.equals(other.minCharacters)
                && punctuationBoundaries.equals(other.punctuationBoundaries)
                && formatPlan.equals(other.formatPlan);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.enabled, this.minCharacters, this.punctuationBoundaries, this.formatPlan);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Boolean> enabled = Optional.empty();

        private Optional<Double> minCharacters = Optional.empty();

        private Optional<List<PunctuationBoundary>> punctuationBoundaries = Optional.empty();

        private Optional<FormatPlan> formatPlan = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(ChunkPlan other) {
            enabled(other.getEnabled());
            minCharacters(other.getMinCharacters());
            punctuationBoundaries(other.getPunctuationBoundaries());
            formatPlan(other.getFormatPlan());
            return this;
        }

        /**
         * <p>This determines whether the model output is chunked before being sent to the voice provider. Default <code>true</code>.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To rely on the voice provider's audio generation logic, set this to <code>false</code>.</li>
         * <li>If seeing issues with quality, set this to <code>true</code>.</li>
         * </ul>
         * <p>If disabled, Vapi-provided audio control tokens like &lt;flush /&gt; will not work.</p>
         * <p>@default true</p>
         */
        @JsonSetter(value = "enabled", nulls = Nulls.SKIP)
        public Builder enabled(Optional<Boolean> enabled) {
            this.enabled = enabled;
            return this;
        }

        public Builder enabled(Boolean enabled) {
            this.enabled = Optional.ofNullable(enabled);
            return this;
        }

        /**
         * <p>This is the minimum number of characters in a chunk.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To increase quality, set this to a higher value.</li>
         * <li>To decrease latency, set this to a lower value.</li>
         * </ul>
         * <p>@default 30</p>
         */
        @JsonSetter(value = "minCharacters", nulls = Nulls.SKIP)
        public Builder minCharacters(Optional<Double> minCharacters) {
            this.minCharacters = minCharacters;
            return this;
        }

        public Builder minCharacters(Double minCharacters) {
            this.minCharacters = Optional.ofNullable(minCharacters);
            return this;
        }

        /**
         * <p>These are the punctuations that are considered valid boundaries for a chunk to be created.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To increase quality, constrain to fewer boundaries.</li>
         * <li>To decrease latency, enable all.</li>
         * </ul>
         * <p>Default is automatically set to balance the trade-off between quality and latency based on the provider.</p>
         */
        @JsonSetter(value = "punctuationBoundaries", nulls = Nulls.SKIP)
        public Builder punctuationBoundaries(Optional<List<PunctuationBoundary>> punctuationBoundaries) {
            this.punctuationBoundaries = punctuationBoundaries;
            return this;
        }

        public Builder punctuationBoundaries(List<PunctuationBoundary> punctuationBoundaries) {
            this.punctuationBoundaries = Optional.ofNullable(punctuationBoundaries);
            return this;
        }

        /**
         * <p>This is the plan for formatting the chunk before it is sent to the voice provider.</p>
         */
        @JsonSetter(value = "formatPlan", nulls = Nulls.SKIP)
        public Builder formatPlan(Optional<FormatPlan> formatPlan) {
            this.formatPlan = formatPlan;
            return this;
        }

        public Builder formatPlan(FormatPlan formatPlan) {
            this.formatPlan = Optional.ofNullable(formatPlan);
            return this;
        }

        public ChunkPlan build() {
            return new ChunkPlan(enabled, minCharacters, punctuationBoundaries, formatPlan, additionalProperties);
        }
    }
}
