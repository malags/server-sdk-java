/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = TrieveKnowledgeBaseChunkPlan.Builder.class)
public final class TrieveKnowledgeBaseChunkPlan {
    private final Optional<List<String>> fileIds;

    private final Optional<List<String>> websites;

    private final Optional<Double> targetSplitsPerChunk;

    private final Optional<List<String>> splitDelimiters;

    private final Optional<Boolean> rebalanceChunks;

    private final Map<String, Object> additionalProperties;

    private TrieveKnowledgeBaseChunkPlan(
            Optional<List<String>> fileIds,
            Optional<List<String>> websites,
            Optional<Double> targetSplitsPerChunk,
            Optional<List<String>> splitDelimiters,
            Optional<Boolean> rebalanceChunks,
            Map<String, Object> additionalProperties) {
        this.fileIds = fileIds;
        this.websites = websites;
        this.targetSplitsPerChunk = targetSplitsPerChunk;
        this.splitDelimiters = splitDelimiters;
        this.rebalanceChunks = rebalanceChunks;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return These are the file ids that will be used to create the vector store. To upload files, use the <code>POST /files</code> endpoint.
     */
    @JsonProperty("fileIds")
    public Optional<List<String>> getFileIds() {
        return fileIds;
    }

    /**
     * @return These are the websites that will be used to create the vector store.
     */
    @JsonProperty("websites")
    public Optional<List<String>> getWebsites() {
        return websites;
    }

    /**
     * @return This is an optional field which allows you to specify the number of splits you want per chunk. If not specified, the default 20 is used. However, you may want to use a different number.
     */
    @JsonProperty("targetSplitsPerChunk")
    public Optional<Double> getTargetSplitsPerChunk() {
        return targetSplitsPerChunk;
    }

    /**
     * @return This is an optional field which allows you to specify the delimiters to use when splitting the file before chunking the text. If not specified, the default [.!?\n] are used to split into sentences. However, you may want to use spaces or other delimiters.
     */
    @JsonProperty("splitDelimiters")
    public Optional<List<String>> getSplitDelimiters() {
        return splitDelimiters;
    }

    /**
     * @return This is an optional field which allows you to specify whether or not to rebalance the chunks created from the file. If not specified, the default true is used. If true, Trieve will evenly distribute remainder splits across chunks such that 66 splits with a target_splits_per_chunk of 20 will result in 3 chunks with 22 splits each.
     */
    @JsonProperty("rebalanceChunks")
    public Optional<Boolean> getRebalanceChunks() {
        return rebalanceChunks;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof TrieveKnowledgeBaseChunkPlan && equalTo((TrieveKnowledgeBaseChunkPlan) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(TrieveKnowledgeBaseChunkPlan other) {
        return fileIds.equals(other.fileIds)
                && websites.equals(other.websites)
                && targetSplitsPerChunk.equals(other.targetSplitsPerChunk)
                && splitDelimiters.equals(other.splitDelimiters)
                && rebalanceChunks.equals(other.rebalanceChunks);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.fileIds, this.websites, this.targetSplitsPerChunk, this.splitDelimiters, this.rebalanceChunks);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<List<String>> fileIds = Optional.empty();

        private Optional<List<String>> websites = Optional.empty();

        private Optional<Double> targetSplitsPerChunk = Optional.empty();

        private Optional<List<String>> splitDelimiters = Optional.empty();

        private Optional<Boolean> rebalanceChunks = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(TrieveKnowledgeBaseChunkPlan other) {
            fileIds(other.getFileIds());
            websites(other.getWebsites());
            targetSplitsPerChunk(other.getTargetSplitsPerChunk());
            splitDelimiters(other.getSplitDelimiters());
            rebalanceChunks(other.getRebalanceChunks());
            return this;
        }

        @JsonSetter(value = "fileIds", nulls = Nulls.SKIP)
        public Builder fileIds(Optional<List<String>> fileIds) {
            this.fileIds = fileIds;
            return this;
        }

        public Builder fileIds(List<String> fileIds) {
            this.fileIds = Optional.ofNullable(fileIds);
            return this;
        }

        @JsonSetter(value = "websites", nulls = Nulls.SKIP)
        public Builder websites(Optional<List<String>> websites) {
            this.websites = websites;
            return this;
        }

        public Builder websites(List<String> websites) {
            this.websites = Optional.ofNullable(websites);
            return this;
        }

        @JsonSetter(value = "targetSplitsPerChunk", nulls = Nulls.SKIP)
        public Builder targetSplitsPerChunk(Optional<Double> targetSplitsPerChunk) {
            this.targetSplitsPerChunk = targetSplitsPerChunk;
            return this;
        }

        public Builder targetSplitsPerChunk(Double targetSplitsPerChunk) {
            this.targetSplitsPerChunk = Optional.ofNullable(targetSplitsPerChunk);
            return this;
        }

        @JsonSetter(value = "splitDelimiters", nulls = Nulls.SKIP)
        public Builder splitDelimiters(Optional<List<String>> splitDelimiters) {
            this.splitDelimiters = splitDelimiters;
            return this;
        }

        public Builder splitDelimiters(List<String> splitDelimiters) {
            this.splitDelimiters = Optional.ofNullable(splitDelimiters);
            return this;
        }

        @JsonSetter(value = "rebalanceChunks", nulls = Nulls.SKIP)
        public Builder rebalanceChunks(Optional<Boolean> rebalanceChunks) {
            this.rebalanceChunks = rebalanceChunks;
            return this;
        }

        public Builder rebalanceChunks(Boolean rebalanceChunks) {
            this.rebalanceChunks = Optional.ofNullable(rebalanceChunks);
            return this;
        }

        public TrieveKnowledgeBaseChunkPlan build() {
            return new TrieveKnowledgeBaseChunkPlan(
                    fileIds, websites, targetSplitsPerChunk, splitDelimiters, rebalanceChunks, additionalProperties);
        }
    }
}
