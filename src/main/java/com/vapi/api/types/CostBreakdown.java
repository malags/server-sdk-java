/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = CostBreakdown.Builder.class)
public final class CostBreakdown {
    private final Optional<Double> transport;

    private final Optional<Double> stt;

    private final Optional<Double> llm;

    private final Optional<Double> tts;

    private final Optional<Double> vapi;

    private final Optional<Double> total;

    private final Optional<Double> llmPromptTokens;

    private final Optional<Double> llmCompletionTokens;

    private final Optional<Double> ttsCharacters;

    private final Optional<AnalysisCostBreakdown> analysisCostBreakdown;

    private final Map<String, Object> additionalProperties;

    private CostBreakdown(
            Optional<Double> transport,
            Optional<Double> stt,
            Optional<Double> llm,
            Optional<Double> tts,
            Optional<Double> vapi,
            Optional<Double> total,
            Optional<Double> llmPromptTokens,
            Optional<Double> llmCompletionTokens,
            Optional<Double> ttsCharacters,
            Optional<AnalysisCostBreakdown> analysisCostBreakdown,
            Map<String, Object> additionalProperties) {
        this.transport = transport;
        this.stt = stt;
        this.llm = llm;
        this.tts = tts;
        this.vapi = vapi;
        this.total = total;
        this.llmPromptTokens = llmPromptTokens;
        this.llmCompletionTokens = llmCompletionTokens;
        this.ttsCharacters = ttsCharacters;
        this.analysisCostBreakdown = analysisCostBreakdown;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return This is the cost of the transport provider, like Twilio or Vonage.
     */
    @JsonProperty("transport")
    public Optional<Double> getTransport() {
        return transport;
    }

    /**
     * @return This is the cost of the speech-to-text service.
     */
    @JsonProperty("stt")
    public Optional<Double> getStt() {
        return stt;
    }

    /**
     * @return This is the cost of the language model.
     */
    @JsonProperty("llm")
    public Optional<Double> getLlm() {
        return llm;
    }

    /**
     * @return This is the cost of the text-to-speech service.
     */
    @JsonProperty("tts")
    public Optional<Double> getTts() {
        return tts;
    }

    /**
     * @return This is the cost of Vapi.
     */
    @JsonProperty("vapi")
    public Optional<Double> getVapi() {
        return vapi;
    }

    /**
     * @return This is the total cost of the call.
     */
    @JsonProperty("total")
    public Optional<Double> getTotal() {
        return total;
    }

    /**
     * @return This is the LLM prompt tokens used for the call.
     */
    @JsonProperty("llmPromptTokens")
    public Optional<Double> getLlmPromptTokens() {
        return llmPromptTokens;
    }

    /**
     * @return This is the LLM completion tokens used for the call.
     */
    @JsonProperty("llmCompletionTokens")
    public Optional<Double> getLlmCompletionTokens() {
        return llmCompletionTokens;
    }

    /**
     * @return This is the TTS characters used for the call.
     */
    @JsonProperty("ttsCharacters")
    public Optional<Double> getTtsCharacters() {
        return ttsCharacters;
    }

    /**
     * @return This is the cost of the analysis.
     */
    @JsonProperty("analysisCostBreakdown")
    public Optional<AnalysisCostBreakdown> getAnalysisCostBreakdown() {
        return analysisCostBreakdown;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof CostBreakdown && equalTo((CostBreakdown) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(CostBreakdown other) {
        return transport.equals(other.transport)
                && stt.equals(other.stt)
                && llm.equals(other.llm)
                && tts.equals(other.tts)
                && vapi.equals(other.vapi)
                && total.equals(other.total)
                && llmPromptTokens.equals(other.llmPromptTokens)
                && llmCompletionTokens.equals(other.llmCompletionTokens)
                && ttsCharacters.equals(other.ttsCharacters)
                && analysisCostBreakdown.equals(other.analysisCostBreakdown);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.transport,
                this.stt,
                this.llm,
                this.tts,
                this.vapi,
                this.total,
                this.llmPromptTokens,
                this.llmCompletionTokens,
                this.ttsCharacters,
                this.analysisCostBreakdown);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Double> transport = Optional.empty();

        private Optional<Double> stt = Optional.empty();

        private Optional<Double> llm = Optional.empty();

        private Optional<Double> tts = Optional.empty();

        private Optional<Double> vapi = Optional.empty();

        private Optional<Double> total = Optional.empty();

        private Optional<Double> llmPromptTokens = Optional.empty();

        private Optional<Double> llmCompletionTokens = Optional.empty();

        private Optional<Double> ttsCharacters = Optional.empty();

        private Optional<AnalysisCostBreakdown> analysisCostBreakdown = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(CostBreakdown other) {
            transport(other.getTransport());
            stt(other.getStt());
            llm(other.getLlm());
            tts(other.getTts());
            vapi(other.getVapi());
            total(other.getTotal());
            llmPromptTokens(other.getLlmPromptTokens());
            llmCompletionTokens(other.getLlmCompletionTokens());
            ttsCharacters(other.getTtsCharacters());
            analysisCostBreakdown(other.getAnalysisCostBreakdown());
            return this;
        }

        @JsonSetter(value = "transport", nulls = Nulls.SKIP)
        public Builder transport(Optional<Double> transport) {
            this.transport = transport;
            return this;
        }

        public Builder transport(Double transport) {
            this.transport = Optional.ofNullable(transport);
            return this;
        }

        @JsonSetter(value = "stt", nulls = Nulls.SKIP)
        public Builder stt(Optional<Double> stt) {
            this.stt = stt;
            return this;
        }

        public Builder stt(Double stt) {
            this.stt = Optional.ofNullable(stt);
            return this;
        }

        @JsonSetter(value = "llm", nulls = Nulls.SKIP)
        public Builder llm(Optional<Double> llm) {
            this.llm = llm;
            return this;
        }

        public Builder llm(Double llm) {
            this.llm = Optional.ofNullable(llm);
            return this;
        }

        @JsonSetter(value = "tts", nulls = Nulls.SKIP)
        public Builder tts(Optional<Double> tts) {
            this.tts = tts;
            return this;
        }

        public Builder tts(Double tts) {
            this.tts = Optional.ofNullable(tts);
            return this;
        }

        @JsonSetter(value = "vapi", nulls = Nulls.SKIP)
        public Builder vapi(Optional<Double> vapi) {
            this.vapi = vapi;
            return this;
        }

        public Builder vapi(Double vapi) {
            this.vapi = Optional.ofNullable(vapi);
            return this;
        }

        @JsonSetter(value = "total", nulls = Nulls.SKIP)
        public Builder total(Optional<Double> total) {
            this.total = total;
            return this;
        }

        public Builder total(Double total) {
            this.total = Optional.ofNullable(total);
            return this;
        }

        @JsonSetter(value = "llmPromptTokens", nulls = Nulls.SKIP)
        public Builder llmPromptTokens(Optional<Double> llmPromptTokens) {
            this.llmPromptTokens = llmPromptTokens;
            return this;
        }

        public Builder llmPromptTokens(Double llmPromptTokens) {
            this.llmPromptTokens = Optional.ofNullable(llmPromptTokens);
            return this;
        }

        @JsonSetter(value = "llmCompletionTokens", nulls = Nulls.SKIP)
        public Builder llmCompletionTokens(Optional<Double> llmCompletionTokens) {
            this.llmCompletionTokens = llmCompletionTokens;
            return this;
        }

        public Builder llmCompletionTokens(Double llmCompletionTokens) {
            this.llmCompletionTokens = Optional.ofNullable(llmCompletionTokens);
            return this;
        }

        @JsonSetter(value = "ttsCharacters", nulls = Nulls.SKIP)
        public Builder ttsCharacters(Optional<Double> ttsCharacters) {
            this.ttsCharacters = ttsCharacters;
            return this;
        }

        public Builder ttsCharacters(Double ttsCharacters) {
            this.ttsCharacters = Optional.ofNullable(ttsCharacters);
            return this;
        }

        @JsonSetter(value = "analysisCostBreakdown", nulls = Nulls.SKIP)
        public Builder analysisCostBreakdown(Optional<AnalysisCostBreakdown> analysisCostBreakdown) {
            this.analysisCostBreakdown = analysisCostBreakdown;
            return this;
        }

        public Builder analysisCostBreakdown(AnalysisCostBreakdown analysisCostBreakdown) {
            this.analysisCostBreakdown = Optional.ofNullable(analysisCostBreakdown);
            return this;
        }

        public CostBreakdown build() {
            return new CostBreakdown(
                    transport,
                    stt,
                    llm,
                    tts,
                    vapi,
                    total,
                    llmPromptTokens,
                    llmCompletionTokens,
                    ttsCharacters,
                    analysisCostBreakdown,
                    additionalProperties);
        }
    }
}
