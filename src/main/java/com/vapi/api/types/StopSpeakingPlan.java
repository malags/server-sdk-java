/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = StopSpeakingPlan.Builder.class)
public final class StopSpeakingPlan {
    private final Optional<Double> numWords;

    private final Optional<Double> voiceSeconds;

    private final Optional<Double> backoffSeconds;

    private final Optional<List<String>> acknowledgementPhrases;

    private final Optional<List<String>> interruptionPhrases;

    private final Map<String, Object> additionalProperties;

    private StopSpeakingPlan(
            Optional<Double> numWords,
            Optional<Double> voiceSeconds,
            Optional<Double> backoffSeconds,
            Optional<List<String>> acknowledgementPhrases,
            Optional<List<String>> interruptionPhrases,
            Map<String, Object> additionalProperties) {
        this.numWords = numWords;
        this.voiceSeconds = voiceSeconds;
        this.backoffSeconds = backoffSeconds;
        this.acknowledgementPhrases = acknowledgementPhrases;
        this.interruptionPhrases = interruptionPhrases;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return This is the number of words that the customer has to say before the assistant will stop talking.
     * <p>Words like &quot;stop&quot;, &quot;actually&quot;, &quot;no&quot;, etc. will always interrupt immediately regardless of this value.</p>
     * <p>Words like &quot;okay&quot;, &quot;yeah&quot;, &quot;right&quot; will never interrupt.</p>
     * <p>When set to 0, <code>voiceSeconds</code> is used in addition to the transcriptions to determine the customer has started speaking.</p>
     * <p>Defaults to 0.</p>
     * <p>@default 0</p>
     */
    @JsonProperty("numWords")
    public Optional<Double> getNumWords() {
        return numWords;
    }

    /**
     * @return This is the seconds customer has to speak before the assistant stops talking. This uses the VAD (Voice Activity Detection) spike to determine if the customer has started speaking.
     * <p>Considerations:</p>
     * <ul>
     * <li>A lower value might be more responsive but could potentially pick up non-speech sounds.</li>
     * <li>A higher value reduces false positives but might slightly delay the detection of speech onset.</li>
     * </ul>
     * <p>This is only used if <code>numWords</code> is set to 0.</p>
     * <p>Defaults to 0.2</p>
     * <p>@default 0.2</p>
     */
    @JsonProperty("voiceSeconds")
    public Optional<Double> getVoiceSeconds() {
        return voiceSeconds;
    }

    /**
     * @return This is the seconds to wait before the assistant will start talking again after being interrupted.
     * <p>Defaults to 1.</p>
     * <p>@default 1</p>
     */
    @JsonProperty("backoffSeconds")
    public Optional<Double> getBackoffSeconds() {
        return backoffSeconds;
    }

    /**
     * @return These are the phrases that will never interrupt the assistant, even if numWords threshold is met.
     * These are typically acknowledgement or backchanneling phrases.
     */
    @JsonProperty("acknowledgementPhrases")
    public Optional<List<String>> getAcknowledgementPhrases() {
        return acknowledgementPhrases;
    }

    /**
     * @return These are the phrases that will always interrupt the assistant immediately, regardless of numWords.
     * These are typically phrases indicating disagreement or desire to stop.
     */
    @JsonProperty("interruptionPhrases")
    public Optional<List<String>> getInterruptionPhrases() {
        return interruptionPhrases;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof StopSpeakingPlan && equalTo((StopSpeakingPlan) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(StopSpeakingPlan other) {
        return numWords.equals(other.numWords)
                && voiceSeconds.equals(other.voiceSeconds)
                && backoffSeconds.equals(other.backoffSeconds)
                && acknowledgementPhrases.equals(other.acknowledgementPhrases)
                && interruptionPhrases.equals(other.interruptionPhrases);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.numWords,
                this.voiceSeconds,
                this.backoffSeconds,
                this.acknowledgementPhrases,
                this.interruptionPhrases);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Double> numWords = Optional.empty();

        private Optional<Double> voiceSeconds = Optional.empty();

        private Optional<Double> backoffSeconds = Optional.empty();

        private Optional<List<String>> acknowledgementPhrases = Optional.empty();

        private Optional<List<String>> interruptionPhrases = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(StopSpeakingPlan other) {
            numWords(other.getNumWords());
            voiceSeconds(other.getVoiceSeconds());
            backoffSeconds(other.getBackoffSeconds());
            acknowledgementPhrases(other.getAcknowledgementPhrases());
            interruptionPhrases(other.getInterruptionPhrases());
            return this;
        }

        @JsonSetter(value = "numWords", nulls = Nulls.SKIP)
        public Builder numWords(Optional<Double> numWords) {
            this.numWords = numWords;
            return this;
        }

        public Builder numWords(Double numWords) {
            this.numWords = Optional.ofNullable(numWords);
            return this;
        }

        @JsonSetter(value = "voiceSeconds", nulls = Nulls.SKIP)
        public Builder voiceSeconds(Optional<Double> voiceSeconds) {
            this.voiceSeconds = voiceSeconds;
            return this;
        }

        public Builder voiceSeconds(Double voiceSeconds) {
            this.voiceSeconds = Optional.ofNullable(voiceSeconds);
            return this;
        }

        @JsonSetter(value = "backoffSeconds", nulls = Nulls.SKIP)
        public Builder backoffSeconds(Optional<Double> backoffSeconds) {
            this.backoffSeconds = backoffSeconds;
            return this;
        }

        public Builder backoffSeconds(Double backoffSeconds) {
            this.backoffSeconds = Optional.ofNullable(backoffSeconds);
            return this;
        }

        @JsonSetter(value = "acknowledgementPhrases", nulls = Nulls.SKIP)
        public Builder acknowledgementPhrases(Optional<List<String>> acknowledgementPhrases) {
            this.acknowledgementPhrases = acknowledgementPhrases;
            return this;
        }

        public Builder acknowledgementPhrases(List<String> acknowledgementPhrases) {
            this.acknowledgementPhrases = Optional.ofNullable(acknowledgementPhrases);
            return this;
        }

        @JsonSetter(value = "interruptionPhrases", nulls = Nulls.SKIP)
        public Builder interruptionPhrases(Optional<List<String>> interruptionPhrases) {
            this.interruptionPhrases = interruptionPhrases;
            return this;
        }

        public Builder interruptionPhrases(List<String> interruptionPhrases) {
            this.interruptionPhrases = Optional.ofNullable(interruptionPhrases);
            return this;
        }

        public StopSpeakingPlan build() {
            return new StopSpeakingPlan(
                    numWords,
                    voiceSeconds,
                    backoffSeconds,
                    acknowledgementPhrases,
                    interruptionPhrases,
                    additionalProperties);
        }
    }
}
