/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = HmacAuthenticationPlan.Builder.class)
public final class HmacAuthenticationPlan {
    private final String secretKey;

    private final HmacAuthenticationPlanAlgorithm algorithm;

    private final Optional<String> signatureHeader;

    private final Optional<String> timestampHeader;

    private final Optional<String> signaturePrefix;

    private final Optional<Boolean> includeTimestamp;

    private final Optional<String> payloadFormat;

    private final Optional<String> messageIdHeader;

    private final Optional<HmacAuthenticationPlanSignatureEncoding> signatureEncoding;

    private final Optional<Boolean> secretIsBase64;

    private final Map<String, Object> additionalProperties;

    private HmacAuthenticationPlan(
            String secretKey,
            HmacAuthenticationPlanAlgorithm algorithm,
            Optional<String> signatureHeader,
            Optional<String> timestampHeader,
            Optional<String> signaturePrefix,
            Optional<Boolean> includeTimestamp,
            Optional<String> payloadFormat,
            Optional<String> messageIdHeader,
            Optional<HmacAuthenticationPlanSignatureEncoding> signatureEncoding,
            Optional<Boolean> secretIsBase64,
            Map<String, Object> additionalProperties) {
        this.secretKey = secretKey;
        this.algorithm = algorithm;
        this.signatureHeader = signatureHeader;
        this.timestampHeader = timestampHeader;
        this.signaturePrefix = signaturePrefix;
        this.includeTimestamp = includeTimestamp;
        this.payloadFormat = payloadFormat;
        this.messageIdHeader = messageIdHeader;
        this.signatureEncoding = signatureEncoding;
        this.secretIsBase64 = secretIsBase64;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return This is the HMAC secret key used to sign requests.
     */
    @JsonProperty("secretKey")
    public String getSecretKey() {
        return secretKey;
    }

    /**
     * @return This is the HMAC algorithm to use for signing.
     */
    @JsonProperty("algorithm")
    public HmacAuthenticationPlanAlgorithm getAlgorithm() {
        return algorithm;
    }

    /**
     * @return This is the header name where the signature will be sent. Defaults to 'x-signature'.
     */
    @JsonProperty("signatureHeader")
    public Optional<String> getSignatureHeader() {
        return signatureHeader;
    }

    /**
     * @return This is the header name where the timestamp will be sent. Defaults to 'x-timestamp'.
     */
    @JsonProperty("timestampHeader")
    public Optional<String> getTimestampHeader() {
        return timestampHeader;
    }

    /**
     * @return This is the prefix for the signature. For example, 'sha256=' for GitHub-style signatures.
     */
    @JsonProperty("signaturePrefix")
    public Optional<String> getSignaturePrefix() {
        return signaturePrefix;
    }

    /**
     * @return Whether to include a timestamp in the signature payload. Defaults to true.
     */
    @JsonProperty("includeTimestamp")
    public Optional<Boolean> getIncludeTimestamp() {
        return includeTimestamp;
    }

    /**
     * @return Custom payload format. Use {body} for request body, {timestamp} for timestamp, {method} for HTTP method, {url} for URL, {svix-id} for unique message ID. Defaults to '{timestamp}.{body}'.
     */
    @JsonProperty("payloadFormat")
    public Optional<String> getPayloadFormat() {
        return payloadFormat;
    }

    /**
     * @return This is the header name where the unique message ID will be sent. Used for Svix-style webhooks.
     */
    @JsonProperty("messageIdHeader")
    public Optional<String> getMessageIdHeader() {
        return messageIdHeader;
    }

    /**
     * @return The encoding format for the signature. Defaults to 'hex'.
     */
    @JsonProperty("signatureEncoding")
    public Optional<HmacAuthenticationPlanSignatureEncoding> getSignatureEncoding() {
        return signatureEncoding;
    }

    /**
     * @return Whether the secret key is base64-encoded and should be decoded before use. Defaults to false.
     */
    @JsonProperty("secretIsBase64")
    public Optional<Boolean> getSecretIsBase64() {
        return secretIsBase64;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof HmacAuthenticationPlan && equalTo((HmacAuthenticationPlan) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(HmacAuthenticationPlan other) {
        return secretKey.equals(other.secretKey)
                && algorithm.equals(other.algorithm)
                && signatureHeader.equals(other.signatureHeader)
                && timestampHeader.equals(other.timestampHeader)
                && signaturePrefix.equals(other.signaturePrefix)
                && includeTimestamp.equals(other.includeTimestamp)
                && payloadFormat.equals(other.payloadFormat)
                && messageIdHeader.equals(other.messageIdHeader)
                && signatureEncoding.equals(other.signatureEncoding)
                && secretIsBase64.equals(other.secretIsBase64);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.secretKey,
                this.algorithm,
                this.signatureHeader,
                this.timestampHeader,
                this.signaturePrefix,
                this.includeTimestamp,
                this.payloadFormat,
                this.messageIdHeader,
                this.signatureEncoding,
                this.secretIsBase64);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static SecretKeyStage builder() {
        return new Builder();
    }

    public interface SecretKeyStage {
        /**
         * <p>This is the HMAC secret key used to sign requests.</p>
         */
        AlgorithmStage secretKey(@NotNull String secretKey);

        Builder from(HmacAuthenticationPlan other);
    }

    public interface AlgorithmStage {
        /**
         * <p>This is the HMAC algorithm to use for signing.</p>
         */
        _FinalStage algorithm(@NotNull HmacAuthenticationPlanAlgorithm algorithm);
    }

    public interface _FinalStage {
        HmacAuthenticationPlan build();

        /**
         * <p>This is the header name where the signature will be sent. Defaults to 'x-signature'.</p>
         */
        _FinalStage signatureHeader(Optional<String> signatureHeader);

        _FinalStage signatureHeader(String signatureHeader);

        /**
         * <p>This is the header name where the timestamp will be sent. Defaults to 'x-timestamp'.</p>
         */
        _FinalStage timestampHeader(Optional<String> timestampHeader);

        _FinalStage timestampHeader(String timestampHeader);

        /**
         * <p>This is the prefix for the signature. For example, 'sha256=' for GitHub-style signatures.</p>
         */
        _FinalStage signaturePrefix(Optional<String> signaturePrefix);

        _FinalStage signaturePrefix(String signaturePrefix);

        /**
         * <p>Whether to include a timestamp in the signature payload. Defaults to true.</p>
         */
        _FinalStage includeTimestamp(Optional<Boolean> includeTimestamp);

        _FinalStage includeTimestamp(Boolean includeTimestamp);

        /**
         * <p>Custom payload format. Use {body} for request body, {timestamp} for timestamp, {method} for HTTP method, {url} for URL, {svix-id} for unique message ID. Defaults to '{timestamp}.{body}'.</p>
         */
        _FinalStage payloadFormat(Optional<String> payloadFormat);

        _FinalStage payloadFormat(String payloadFormat);

        /**
         * <p>This is the header name where the unique message ID will be sent. Used for Svix-style webhooks.</p>
         */
        _FinalStage messageIdHeader(Optional<String> messageIdHeader);

        _FinalStage messageIdHeader(String messageIdHeader);

        /**
         * <p>The encoding format for the signature. Defaults to 'hex'.</p>
         */
        _FinalStage signatureEncoding(Optional<HmacAuthenticationPlanSignatureEncoding> signatureEncoding);

        _FinalStage signatureEncoding(HmacAuthenticationPlanSignatureEncoding signatureEncoding);

        /**
         * <p>Whether the secret key is base64-encoded and should be decoded before use. Defaults to false.</p>
         */
        _FinalStage secretIsBase64(Optional<Boolean> secretIsBase64);

        _FinalStage secretIsBase64(Boolean secretIsBase64);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements SecretKeyStage, AlgorithmStage, _FinalStage {
        private String secretKey;

        private HmacAuthenticationPlanAlgorithm algorithm;

        private Optional<Boolean> secretIsBase64 = Optional.empty();

        private Optional<HmacAuthenticationPlanSignatureEncoding> signatureEncoding = Optional.empty();

        private Optional<String> messageIdHeader = Optional.empty();

        private Optional<String> payloadFormat = Optional.empty();

        private Optional<Boolean> includeTimestamp = Optional.empty();

        private Optional<String> signaturePrefix = Optional.empty();

        private Optional<String> timestampHeader = Optional.empty();

        private Optional<String> signatureHeader = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(HmacAuthenticationPlan other) {
            secretKey(other.getSecretKey());
            algorithm(other.getAlgorithm());
            signatureHeader(other.getSignatureHeader());
            timestampHeader(other.getTimestampHeader());
            signaturePrefix(other.getSignaturePrefix());
            includeTimestamp(other.getIncludeTimestamp());
            payloadFormat(other.getPayloadFormat());
            messageIdHeader(other.getMessageIdHeader());
            signatureEncoding(other.getSignatureEncoding());
            secretIsBase64(other.getSecretIsBase64());
            return this;
        }

        /**
         * <p>This is the HMAC secret key used to sign requests.</p>
         * <p>This is the HMAC secret key used to sign requests.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("secretKey")
        public AlgorithmStage secretKey(@NotNull String secretKey) {
            this.secretKey = Objects.requireNonNull(secretKey, "secretKey must not be null");
            return this;
        }

        /**
         * <p>This is the HMAC algorithm to use for signing.</p>
         * <p>This is the HMAC algorithm to use for signing.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("algorithm")
        public _FinalStage algorithm(@NotNull HmacAuthenticationPlanAlgorithm algorithm) {
            this.algorithm = Objects.requireNonNull(algorithm, "algorithm must not be null");
            return this;
        }

        /**
         * <p>Whether the secret key is base64-encoded and should be decoded before use. Defaults to false.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage secretIsBase64(Boolean secretIsBase64) {
            this.secretIsBase64 = Optional.ofNullable(secretIsBase64);
            return this;
        }

        /**
         * <p>Whether the secret key is base64-encoded and should be decoded before use. Defaults to false.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "secretIsBase64", nulls = Nulls.SKIP)
        public _FinalStage secretIsBase64(Optional<Boolean> secretIsBase64) {
            this.secretIsBase64 = secretIsBase64;
            return this;
        }

        /**
         * <p>The encoding format for the signature. Defaults to 'hex'.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage signatureEncoding(HmacAuthenticationPlanSignatureEncoding signatureEncoding) {
            this.signatureEncoding = Optional.ofNullable(signatureEncoding);
            return this;
        }

        /**
         * <p>The encoding format for the signature. Defaults to 'hex'.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "signatureEncoding", nulls = Nulls.SKIP)
        public _FinalStage signatureEncoding(Optional<HmacAuthenticationPlanSignatureEncoding> signatureEncoding) {
            this.signatureEncoding = signatureEncoding;
            return this;
        }

        /**
         * <p>This is the header name where the unique message ID will be sent. Used for Svix-style webhooks.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage messageIdHeader(String messageIdHeader) {
            this.messageIdHeader = Optional.ofNullable(messageIdHeader);
            return this;
        }

        /**
         * <p>This is the header name where the unique message ID will be sent. Used for Svix-style webhooks.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "messageIdHeader", nulls = Nulls.SKIP)
        public _FinalStage messageIdHeader(Optional<String> messageIdHeader) {
            this.messageIdHeader = messageIdHeader;
            return this;
        }

        /**
         * <p>Custom payload format. Use {body} for request body, {timestamp} for timestamp, {method} for HTTP method, {url} for URL, {svix-id} for unique message ID. Defaults to '{timestamp}.{body}'.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage payloadFormat(String payloadFormat) {
            this.payloadFormat = Optional.ofNullable(payloadFormat);
            return this;
        }

        /**
         * <p>Custom payload format. Use {body} for request body, {timestamp} for timestamp, {method} for HTTP method, {url} for URL, {svix-id} for unique message ID. Defaults to '{timestamp}.{body}'.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "payloadFormat", nulls = Nulls.SKIP)
        public _FinalStage payloadFormat(Optional<String> payloadFormat) {
            this.payloadFormat = payloadFormat;
            return this;
        }

        /**
         * <p>Whether to include a timestamp in the signature payload. Defaults to true.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage includeTimestamp(Boolean includeTimestamp) {
            this.includeTimestamp = Optional.ofNullable(includeTimestamp);
            return this;
        }

        /**
         * <p>Whether to include a timestamp in the signature payload. Defaults to true.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "includeTimestamp", nulls = Nulls.SKIP)
        public _FinalStage includeTimestamp(Optional<Boolean> includeTimestamp) {
            this.includeTimestamp = includeTimestamp;
            return this;
        }

        /**
         * <p>This is the prefix for the signature. For example, 'sha256=' for GitHub-style signatures.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage signaturePrefix(String signaturePrefix) {
            this.signaturePrefix = Optional.ofNullable(signaturePrefix);
            return this;
        }

        /**
         * <p>This is the prefix for the signature. For example, 'sha256=' for GitHub-style signatures.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "signaturePrefix", nulls = Nulls.SKIP)
        public _FinalStage signaturePrefix(Optional<String> signaturePrefix) {
            this.signaturePrefix = signaturePrefix;
            return this;
        }

        /**
         * <p>This is the header name where the timestamp will be sent. Defaults to 'x-timestamp'.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage timestampHeader(String timestampHeader) {
            this.timestampHeader = Optional.ofNullable(timestampHeader);
            return this;
        }

        /**
         * <p>This is the header name where the timestamp will be sent. Defaults to 'x-timestamp'.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "timestampHeader", nulls = Nulls.SKIP)
        public _FinalStage timestampHeader(Optional<String> timestampHeader) {
            this.timestampHeader = timestampHeader;
            return this;
        }

        /**
         * <p>This is the header name where the signature will be sent. Defaults to 'x-signature'.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage signatureHeader(String signatureHeader) {
            this.signatureHeader = Optional.ofNullable(signatureHeader);
            return this;
        }

        /**
         * <p>This is the header name where the signature will be sent. Defaults to 'x-signature'.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "signatureHeader", nulls = Nulls.SKIP)
        public _FinalStage signatureHeader(Optional<String> signatureHeader) {
            this.signatureHeader = signatureHeader;
            return this;
        }

        @java.lang.Override
        public HmacAuthenticationPlan build() {
            return new HmacAuthenticationPlan(
                    secretKey,
                    algorithm,
                    signatureHeader,
                    timestampHeader,
                    signaturePrefix,
                    includeTimestamp,
                    payloadFormat,
                    messageIdHeader,
                    signatureEncoding,
                    secretIsBase64,
                    additionalProperties);
        }
    }
}
