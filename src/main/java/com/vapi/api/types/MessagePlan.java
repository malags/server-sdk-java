/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = MessagePlan.Builder.class)
public final class MessagePlan {
    private final Optional<List<String>> idleMessages;

    private final Optional<Double> idleMessageMaxSpokenCount;

    private final Optional<Boolean> idleMessageResetCountOnUserSpeechEnabled;

    private final Optional<Double> idleTimeoutSeconds;

    private final Optional<String> silenceTimeoutMessage;

    private final Map<String, Object> additionalProperties;

    private MessagePlan(
            Optional<List<String>> idleMessages,
            Optional<Double> idleMessageMaxSpokenCount,
            Optional<Boolean> idleMessageResetCountOnUserSpeechEnabled,
            Optional<Double> idleTimeoutSeconds,
            Optional<String> silenceTimeoutMessage,
            Map<String, Object> additionalProperties) {
        this.idleMessages = idleMessages;
        this.idleMessageMaxSpokenCount = idleMessageMaxSpokenCount;
        this.idleMessageResetCountOnUserSpeechEnabled = idleMessageResetCountOnUserSpeechEnabled;
        this.idleTimeoutSeconds = idleTimeoutSeconds;
        this.silenceTimeoutMessage = silenceTimeoutMessage;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return This are the messages that the assistant will speak when the user hasn't responded for <code>idleTimeoutSeconds</code>. Each time the timeout is triggered, a random message will be chosen from this array.
     * <p>Usage:</p>
     * <ul>
     * <li>If user gets distracted and doesn't respond for a while, this can be used to grab their attention.</li>
     * <li>If the transcriber doesn't pick up what the user said, this can be used to ask the user to repeat themselves. (From the perspective of the assistant, the conversation is idle since it didn't &quot;hear&quot; any user messages.)</li>
     * </ul>
     * <p>@default null (no idle message is spoken)</p>
     */
    @JsonProperty("idleMessages")
    public Optional<List<String>> getIdleMessages() {
        return idleMessages;
    }

    /**
     * @return This determines the maximum number of times <code>idleMessages</code> can be spoken during the call.
     * <p>@default 3</p>
     */
    @JsonProperty("idleMessageMaxSpokenCount")
    public Optional<Double> getIdleMessageMaxSpokenCount() {
        return idleMessageMaxSpokenCount;
    }

    /**
     * @return This determines whether the idle message count is reset whenever the user speaks.
     * <p>@default false</p>
     */
    @JsonProperty("idleMessageResetCountOnUserSpeechEnabled")
    public Optional<Boolean> getIdleMessageResetCountOnUserSpeechEnabled() {
        return idleMessageResetCountOnUserSpeechEnabled;
    }

    /**
     * @return This is the timeout in seconds before a message from <code>idleMessages</code> is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks.
     * <p>@default 10</p>
     */
    @JsonProperty("idleTimeoutSeconds")
    public Optional<Double> getIdleTimeoutSeconds() {
        return idleTimeoutSeconds;
    }

    /**
     * @return This is the message that the assistant will say if the call ends due to silence.
     * <p>If unspecified, it will hang up without saying anything.</p>
     */
    @JsonProperty("silenceTimeoutMessage")
    public Optional<String> getSilenceTimeoutMessage() {
        return silenceTimeoutMessage;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof MessagePlan && equalTo((MessagePlan) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(MessagePlan other) {
        return idleMessages.equals(other.idleMessages)
                && idleMessageMaxSpokenCount.equals(other.idleMessageMaxSpokenCount)
                && idleMessageResetCountOnUserSpeechEnabled.equals(other.idleMessageResetCountOnUserSpeechEnabled)
                && idleTimeoutSeconds.equals(other.idleTimeoutSeconds)
                && silenceTimeoutMessage.equals(other.silenceTimeoutMessage);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.idleMessages,
                this.idleMessageMaxSpokenCount,
                this.idleMessageResetCountOnUserSpeechEnabled,
                this.idleTimeoutSeconds,
                this.silenceTimeoutMessage);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<List<String>> idleMessages = Optional.empty();

        private Optional<Double> idleMessageMaxSpokenCount = Optional.empty();

        private Optional<Boolean> idleMessageResetCountOnUserSpeechEnabled = Optional.empty();

        private Optional<Double> idleTimeoutSeconds = Optional.empty();

        private Optional<String> silenceTimeoutMessage = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(MessagePlan other) {
            idleMessages(other.getIdleMessages());
            idleMessageMaxSpokenCount(other.getIdleMessageMaxSpokenCount());
            idleMessageResetCountOnUserSpeechEnabled(other.getIdleMessageResetCountOnUserSpeechEnabled());
            idleTimeoutSeconds(other.getIdleTimeoutSeconds());
            silenceTimeoutMessage(other.getSilenceTimeoutMessage());
            return this;
        }

        /**
         * <p>This are the messages that the assistant will speak when the user hasn't responded for <code>idleTimeoutSeconds</code>. Each time the timeout is triggered, a random message will be chosen from this array.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>If user gets distracted and doesn't respond for a while, this can be used to grab their attention.</li>
         * <li>If the transcriber doesn't pick up what the user said, this can be used to ask the user to repeat themselves. (From the perspective of the assistant, the conversation is idle since it didn't &quot;hear&quot; any user messages.)</li>
         * </ul>
         * <p>@default null (no idle message is spoken)</p>
         */
        @JsonSetter(value = "idleMessages", nulls = Nulls.SKIP)
        public Builder idleMessages(Optional<List<String>> idleMessages) {
            this.idleMessages = idleMessages;
            return this;
        }

        public Builder idleMessages(List<String> idleMessages) {
            this.idleMessages = Optional.ofNullable(idleMessages);
            return this;
        }

        /**
         * <p>This determines the maximum number of times <code>idleMessages</code> can be spoken during the call.</p>
         * <p>@default 3</p>
         */
        @JsonSetter(value = "idleMessageMaxSpokenCount", nulls = Nulls.SKIP)
        public Builder idleMessageMaxSpokenCount(Optional<Double> idleMessageMaxSpokenCount) {
            this.idleMessageMaxSpokenCount = idleMessageMaxSpokenCount;
            return this;
        }

        public Builder idleMessageMaxSpokenCount(Double idleMessageMaxSpokenCount) {
            this.idleMessageMaxSpokenCount = Optional.ofNullable(idleMessageMaxSpokenCount);
            return this;
        }

        /**
         * <p>This determines whether the idle message count is reset whenever the user speaks.</p>
         * <p>@default false</p>
         */
        @JsonSetter(value = "idleMessageResetCountOnUserSpeechEnabled", nulls = Nulls.SKIP)
        public Builder idleMessageResetCountOnUserSpeechEnabled(
                Optional<Boolean> idleMessageResetCountOnUserSpeechEnabled) {
            this.idleMessageResetCountOnUserSpeechEnabled = idleMessageResetCountOnUserSpeechEnabled;
            return this;
        }

        public Builder idleMessageResetCountOnUserSpeechEnabled(Boolean idleMessageResetCountOnUserSpeechEnabled) {
            this.idleMessageResetCountOnUserSpeechEnabled =
                    Optional.ofNullable(idleMessageResetCountOnUserSpeechEnabled);
            return this;
        }

        /**
         * <p>This is the timeout in seconds before a message from <code>idleMessages</code> is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks.</p>
         * <p>@default 10</p>
         */
        @JsonSetter(value = "idleTimeoutSeconds", nulls = Nulls.SKIP)
        public Builder idleTimeoutSeconds(Optional<Double> idleTimeoutSeconds) {
            this.idleTimeoutSeconds = idleTimeoutSeconds;
            return this;
        }

        public Builder idleTimeoutSeconds(Double idleTimeoutSeconds) {
            this.idleTimeoutSeconds = Optional.ofNullable(idleTimeoutSeconds);
            return this;
        }

        /**
         * <p>This is the message that the assistant will say if the call ends due to silence.</p>
         * <p>If unspecified, it will hang up without saying anything.</p>
         */
        @JsonSetter(value = "silenceTimeoutMessage", nulls = Nulls.SKIP)
        public Builder silenceTimeoutMessage(Optional<String> silenceTimeoutMessage) {
            this.silenceTimeoutMessage = silenceTimeoutMessage;
            return this;
        }

        public Builder silenceTimeoutMessage(String silenceTimeoutMessage) {
            this.silenceTimeoutMessage = Optional.ofNullable(silenceTimeoutMessage);
            return this;
        }

        public MessagePlan build() {
            return new MessagePlan(
                    idleMessages,
                    idleMessageMaxSpokenCount,
                    idleMessageResetCountOnUserSpeechEnabled,
                    idleTimeoutSeconds,
                    silenceTimeoutMessage,
                    additionalProperties);
        }
    }
}
