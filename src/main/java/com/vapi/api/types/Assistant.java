/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = Assistant.Builder.class)
public final class Assistant {
    private final Optional<AssistantTranscriber> transcriber;

    private final Optional<AssistantModel> model;

    private final Optional<AssistantVoice> voice;

    private final Optional<String> firstMessage;

    private final Optional<Boolean> firstMessageInterruptionsEnabled;

    private final Optional<AssistantFirstMessageMode> firstMessageMode;

    private final Optional<AssistantVoicemailDetection> voicemailDetection;

    private final Optional<List<AssistantClientMessagesItem>> clientMessages;

    private final Optional<List<AssistantServerMessagesItem>> serverMessages;

    private final Optional<Double> silenceTimeoutSeconds;

    private final Optional<Double> maxDurationSeconds;

    private final Optional<AssistantBackgroundSound> backgroundSound;

    private final Optional<Boolean> backgroundDenoisingEnabled;

    private final Optional<Boolean> modelOutputInMessagesEnabled;

    private final Optional<List<TransportConfigurationTwilio>> transportConfigurations;

    private final Optional<LangfuseObservabilityPlan> observabilityPlan;

    private final Optional<List<AssistantCredentialsItem>> credentials;

    private final Optional<List<AssistantHooksItem>> hooks;

    private final Optional<String> name;

    private final Optional<String> voicemailMessage;

    private final Optional<String> endCallMessage;

    private final Optional<List<String>> endCallPhrases;

    private final Optional<CompliancePlan> compliancePlan;

    private final Optional<Map<String, Object>> metadata;

    private final Optional<BackgroundSpeechDenoisingPlan> backgroundSpeechDenoisingPlan;

    private final Optional<AnalysisPlan> analysisPlan;

    private final Optional<ArtifactPlan> artifactPlan;

    private final Optional<MessagePlan> messagePlan;

    private final Optional<StartSpeakingPlan> startSpeakingPlan;

    private final Optional<StopSpeakingPlan> stopSpeakingPlan;

    private final Optional<MonitorPlan> monitorPlan;

    private final Optional<List<String>> credentialIds;

    private final Optional<Server> server;

    private final Optional<KeypadInputPlan> keypadInputPlan;

    private final String id;

    private final String orgId;

    private final OffsetDateTime createdAt;

    private final OffsetDateTime updatedAt;

    private final Map<String, Object> additionalProperties;

    private Assistant(
            Optional<AssistantTranscriber> transcriber,
            Optional<AssistantModel> model,
            Optional<AssistantVoice> voice,
            Optional<String> firstMessage,
            Optional<Boolean> firstMessageInterruptionsEnabled,
            Optional<AssistantFirstMessageMode> firstMessageMode,
            Optional<AssistantVoicemailDetection> voicemailDetection,
            Optional<List<AssistantClientMessagesItem>> clientMessages,
            Optional<List<AssistantServerMessagesItem>> serverMessages,
            Optional<Double> silenceTimeoutSeconds,
            Optional<Double> maxDurationSeconds,
            Optional<AssistantBackgroundSound> backgroundSound,
            Optional<Boolean> backgroundDenoisingEnabled,
            Optional<Boolean> modelOutputInMessagesEnabled,
            Optional<List<TransportConfigurationTwilio>> transportConfigurations,
            Optional<LangfuseObservabilityPlan> observabilityPlan,
            Optional<List<AssistantCredentialsItem>> credentials,
            Optional<List<AssistantHooksItem>> hooks,
            Optional<String> name,
            Optional<String> voicemailMessage,
            Optional<String> endCallMessage,
            Optional<List<String>> endCallPhrases,
            Optional<CompliancePlan> compliancePlan,
            Optional<Map<String, Object>> metadata,
            Optional<BackgroundSpeechDenoisingPlan> backgroundSpeechDenoisingPlan,
            Optional<AnalysisPlan> analysisPlan,
            Optional<ArtifactPlan> artifactPlan,
            Optional<MessagePlan> messagePlan,
            Optional<StartSpeakingPlan> startSpeakingPlan,
            Optional<StopSpeakingPlan> stopSpeakingPlan,
            Optional<MonitorPlan> monitorPlan,
            Optional<List<String>> credentialIds,
            Optional<Server> server,
            Optional<KeypadInputPlan> keypadInputPlan,
            String id,
            String orgId,
            OffsetDateTime createdAt,
            OffsetDateTime updatedAt,
            Map<String, Object> additionalProperties) {
        this.transcriber = transcriber;
        this.model = model;
        this.voice = voice;
        this.firstMessage = firstMessage;
        this.firstMessageInterruptionsEnabled = firstMessageInterruptionsEnabled;
        this.firstMessageMode = firstMessageMode;
        this.voicemailDetection = voicemailDetection;
        this.clientMessages = clientMessages;
        this.serverMessages = serverMessages;
        this.silenceTimeoutSeconds = silenceTimeoutSeconds;
        this.maxDurationSeconds = maxDurationSeconds;
        this.backgroundSound = backgroundSound;
        this.backgroundDenoisingEnabled = backgroundDenoisingEnabled;
        this.modelOutputInMessagesEnabled = modelOutputInMessagesEnabled;
        this.transportConfigurations = transportConfigurations;
        this.observabilityPlan = observabilityPlan;
        this.credentials = credentials;
        this.hooks = hooks;
        this.name = name;
        this.voicemailMessage = voicemailMessage;
        this.endCallMessage = endCallMessage;
        this.endCallPhrases = endCallPhrases;
        this.compliancePlan = compliancePlan;
        this.metadata = metadata;
        this.backgroundSpeechDenoisingPlan = backgroundSpeechDenoisingPlan;
        this.analysisPlan = analysisPlan;
        this.artifactPlan = artifactPlan;
        this.messagePlan = messagePlan;
        this.startSpeakingPlan = startSpeakingPlan;
        this.stopSpeakingPlan = stopSpeakingPlan;
        this.monitorPlan = monitorPlan;
        this.credentialIds = credentialIds;
        this.server = server;
        this.keypadInputPlan = keypadInputPlan;
        this.id = id;
        this.orgId = orgId;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return These are the options for the assistant's transcriber.
     */
    @JsonProperty("transcriber")
    public Optional<AssistantTranscriber> getTranscriber() {
        return transcriber;
    }

    /**
     * @return These are the options for the assistant's LLM.
     */
    @JsonProperty("model")
    public Optional<AssistantModel> getModel() {
        return model;
    }

    /**
     * @return These are the options for the assistant's voice.
     */
    @JsonProperty("voice")
    public Optional<AssistantVoice> getVoice() {
        return voice;
    }

    /**
     * @return This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
     * <p>If unspecified, assistant will wait for user to speak and use the model to respond once they speak.</p>
     */
    @JsonProperty("firstMessage")
    public Optional<String> getFirstMessage() {
        return firstMessage;
    }

    @JsonProperty("firstMessageInterruptionsEnabled")
    public Optional<Boolean> getFirstMessageInterruptionsEnabled() {
        return firstMessageInterruptionsEnabled;
    }

    /**
     * @return This is the mode for the first message. Default is 'assistant-speaks-first'.
     * <p>Use:</p>
     * <ul>
     * <li>'assistant-speaks-first' to have the assistant speak first.</li>
     * <li>'assistant-waits-for-user' to have the assistant wait for the user to speak first.</li>
     * <li>'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (<code>assistant.model.messages</code> at call start, <code>call.messages</code> at squad transfer points).</li>
     * </ul>
     * <p>@default 'assistant-speaks-first'</p>
     */
    @JsonProperty("firstMessageMode")
    public Optional<AssistantFirstMessageMode> getFirstMessageMode() {
        return firstMessageMode;
    }

    /**
     * @return These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
     * This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
     * You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
     */
    @JsonProperty("voicemailDetection")
    public Optional<AssistantVoicemailDetection> getVoicemailDetection() {
        return voicemailDetection;
    }

    /**
     * @return These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.
     */
    @JsonProperty("clientMessages")
    public Optional<List<AssistantClientMessagesItem>> getClientMessages() {
        return clientMessages;
    }

    /**
     * @return These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
     */
    @JsonProperty("serverMessages")
    public Optional<List<AssistantServerMessagesItem>> getServerMessages() {
        return serverMessages;
    }

    /**
     * @return How many seconds of silence to wait before ending the call. Defaults to 30.
     * <p>@default 30</p>
     */
    @JsonProperty("silenceTimeoutSeconds")
    public Optional<Double> getSilenceTimeoutSeconds() {
        return silenceTimeoutSeconds;
    }

    /**
     * @return This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
     * <p>@default 600 (10 minutes)</p>
     */
    @JsonProperty("maxDurationSeconds")
    public Optional<Double> getMaxDurationSeconds() {
        return maxDurationSeconds;
    }

    /**
     * @return This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
     * You can also provide a custom sound by providing a URL to an audio file.
     */
    @JsonProperty("backgroundSound")
    public Optional<AssistantBackgroundSound> getBackgroundSound() {
        return backgroundSound;
    }

    /**
     * @return This enables filtering of noise and background speech while the user is talking.
     * <p>Default <code>false</code> while in beta.</p>
     * <p>@default false</p>
     */
    @JsonProperty("backgroundDenoisingEnabled")
    public Optional<Boolean> getBackgroundDenoisingEnabled() {
        return backgroundDenoisingEnabled;
    }

    /**
     * @return This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
     * <p>Default <code>false</code> while in beta.</p>
     * <p>@default false</p>
     */
    @JsonProperty("modelOutputInMessagesEnabled")
    public Optional<Boolean> getModelOutputInMessagesEnabled() {
        return modelOutputInMessagesEnabled;
    }

    /**
     * @return These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
     */
    @JsonProperty("transportConfigurations")
    public Optional<List<TransportConfigurationTwilio>> getTransportConfigurations() {
        return transportConfigurations;
    }

    /**
     * @return This is the plan for observability of assistant's calls.
     * <p>Currently, only Langfuse is supported.</p>
     */
    @JsonProperty("observabilityPlan")
    public Optional<LangfuseObservabilityPlan> getObservabilityPlan() {
        return observabilityPlan;
    }

    /**
     * @return These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.
     */
    @JsonProperty("credentials")
    public Optional<List<AssistantCredentialsItem>> getCredentials() {
        return credentials;
    }

    /**
     * @return This is a set of actions that will be performed on certain events.
     */
    @JsonProperty("hooks")
    public Optional<List<AssistantHooksItem>> getHooks() {
        return hooks;
    }

    /**
     * @return This is the name of the assistant.
     * <p>This is required when you want to transfer between assistants in a call.</p>
     */
    @JsonProperty("name")
    public Optional<String> getName() {
        return name;
    }

    /**
     * @return This is the message that the assistant will say if the call is forwarded to voicemail.
     * <p>If unspecified, it will hang up.</p>
     */
    @JsonProperty("voicemailMessage")
    public Optional<String> getVoicemailMessage() {
        return voicemailMessage;
    }

    /**
     * @return This is the message that the assistant will say if it ends the call.
     * <p>If unspecified, it will hang up without saying anything.</p>
     */
    @JsonProperty("endCallMessage")
    public Optional<String> getEndCallMessage() {
        return endCallMessage;
    }

    /**
     * @return This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
     */
    @JsonProperty("endCallPhrases")
    public Optional<List<String>> getEndCallPhrases() {
        return endCallPhrases;
    }

    @JsonProperty("compliancePlan")
    public Optional<CompliancePlan> getCompliancePlan() {
        return compliancePlan;
    }

    /**
     * @return This is for metadata you want to store on the assistant.
     */
    @JsonProperty("metadata")
    public Optional<Map<String, Object>> getMetadata() {
        return metadata;
    }

    /**
     * @return This enables filtering of noise and background speech while the user is talking.
     * <p>Features:</p>
     * <ul>
     * <li>Smart denoising using Krisp</li>
     * <li>Fourier denoising</li>
     * </ul>
     * <p>Smart denoising can be combined with or used independently of Fourier denoising.</p>
     * <p>Order of precedence:</p>
     * <ul>
     * <li>Smart denoising</li>
     * <li>Fourier denoising</li>
     * </ul>
     */
    @JsonProperty("backgroundSpeechDenoisingPlan")
    public Optional<BackgroundSpeechDenoisingPlan> getBackgroundSpeechDenoisingPlan() {
        return backgroundSpeechDenoisingPlan;
    }

    /**
     * @return This is the plan for analysis of assistant's calls. Stored in <code>call.analysis</code>.
     */
    @JsonProperty("analysisPlan")
    public Optional<AnalysisPlan> getAnalysisPlan() {
        return analysisPlan;
    }

    /**
     * @return This is the plan for artifacts generated during assistant's calls. Stored in <code>call.artifact</code>.
     */
    @JsonProperty("artifactPlan")
    public Optional<ArtifactPlan> getArtifactPlan() {
        return artifactPlan;
    }

    /**
     * @return This is the plan for static predefined messages that can be spoken by the assistant during the call, like <code>idleMessages</code>.
     * <p>Note: <code>firstMessage</code>, <code>voicemailMessage</code>, and <code>endCallMessage</code> are currently at the root level. They will be moved to <code>messagePlan</code> in the future, but will remain backwards compatible.</p>
     */
    @JsonProperty("messagePlan")
    public Optional<MessagePlan> getMessagePlan() {
        return messagePlan;
    }

    /**
     * @return This is the plan for when the assistant should start talking.
     * <p>You should configure this if you're running into these issues:</p>
     * <ul>
     * <li>The assistant is too slow to start talking after the customer is done speaking.</li>
     * <li>The assistant is too fast to start talking after the customer is done speaking.</li>
     * <li>The assistant is so fast that it's actually interrupting the customer.</li>
     * </ul>
     */
    @JsonProperty("startSpeakingPlan")
    public Optional<StartSpeakingPlan> getStartSpeakingPlan() {
        return startSpeakingPlan;
    }

    /**
     * @return This is the plan for when assistant should stop talking on customer interruption.
     * <p>You should configure this if you're running into these issues:</p>
     * <ul>
     * <li>The assistant is too slow to recognize customer's interruption.</li>
     * <li>The assistant is too fast to recognize customer's interruption.</li>
     * <li>The assistant is getting interrupted by phrases that are just acknowledgments.</li>
     * <li>The assistant is getting interrupted by background noises.</li>
     * <li>The assistant is not properly stopping -- it starts talking right after getting interrupted.</li>
     * </ul>
     */
    @JsonProperty("stopSpeakingPlan")
    public Optional<StopSpeakingPlan> getStopSpeakingPlan() {
        return stopSpeakingPlan;
    }

    /**
     * @return This is the plan for real-time monitoring of the assistant's calls.
     * <p>Usage:</p>
     * <ul>
     * <li>To enable live listening of the assistant's calls, set <code>monitorPlan.listenEnabled</code> to <code>true</code>.</li>
     * <li>To enable live control of the assistant's calls, set <code>monitorPlan.controlEnabled</code> to <code>true</code>.</li>
     * </ul>
     */
    @JsonProperty("monitorPlan")
    public Optional<MonitorPlan> getMonitorPlan() {
        return monitorPlan;
    }

    /**
     * @return These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
     */
    @JsonProperty("credentialIds")
    public Optional<List<String>> getCredentialIds() {
        return credentialIds;
    }

    /**
     * @return This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
     * <p>The order of precedence is:</p>
     * <ol>
     * <li>assistant.server.url</li>
     * <li>phoneNumber.serverUrl</li>
     * <li>org.serverUrl</li>
     * </ol>
     */
    @JsonProperty("server")
    public Optional<Server> getServer() {
        return server;
    }

    @JsonProperty("keypadInputPlan")
    public Optional<KeypadInputPlan> getKeypadInputPlan() {
        return keypadInputPlan;
    }

    /**
     * @return This is the unique identifier for the assistant.
     */
    @JsonProperty("id")
    public String getId() {
        return id;
    }

    /**
     * @return This is the unique identifier for the org that this assistant belongs to.
     */
    @JsonProperty("orgId")
    public String getOrgId() {
        return orgId;
    }

    /**
     * @return This is the ISO 8601 date-time string of when the assistant was created.
     */
    @JsonProperty("createdAt")
    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    /**
     * @return This is the ISO 8601 date-time string of when the assistant was last updated.
     */
    @JsonProperty("updatedAt")
    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof Assistant && equalTo((Assistant) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(Assistant other) {
        return transcriber.equals(other.transcriber)
                && model.equals(other.model)
                && voice.equals(other.voice)
                && firstMessage.equals(other.firstMessage)
                && firstMessageInterruptionsEnabled.equals(other.firstMessageInterruptionsEnabled)
                && firstMessageMode.equals(other.firstMessageMode)
                && voicemailDetection.equals(other.voicemailDetection)
                && clientMessages.equals(other.clientMessages)
                && serverMessages.equals(other.serverMessages)
                && silenceTimeoutSeconds.equals(other.silenceTimeoutSeconds)
                && maxDurationSeconds.equals(other.maxDurationSeconds)
                && backgroundSound.equals(other.backgroundSound)
                && backgroundDenoisingEnabled.equals(other.backgroundDenoisingEnabled)
                && modelOutputInMessagesEnabled.equals(other.modelOutputInMessagesEnabled)
                && transportConfigurations.equals(other.transportConfigurations)
                && observabilityPlan.equals(other.observabilityPlan)
                && credentials.equals(other.credentials)
                && hooks.equals(other.hooks)
                && name.equals(other.name)
                && voicemailMessage.equals(other.voicemailMessage)
                && endCallMessage.equals(other.endCallMessage)
                && endCallPhrases.equals(other.endCallPhrases)
                && compliancePlan.equals(other.compliancePlan)
                && metadata.equals(other.metadata)
                && backgroundSpeechDenoisingPlan.equals(other.backgroundSpeechDenoisingPlan)
                && analysisPlan.equals(other.analysisPlan)
                && artifactPlan.equals(other.artifactPlan)
                && messagePlan.equals(other.messagePlan)
                && startSpeakingPlan.equals(other.startSpeakingPlan)
                && stopSpeakingPlan.equals(other.stopSpeakingPlan)
                && monitorPlan.equals(other.monitorPlan)
                && credentialIds.equals(other.credentialIds)
                && server.equals(other.server)
                && keypadInputPlan.equals(other.keypadInputPlan)
                && id.equals(other.id)
                && orgId.equals(other.orgId)
                && createdAt.equals(other.createdAt)
                && updatedAt.equals(other.updatedAt);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.transcriber,
                this.model,
                this.voice,
                this.firstMessage,
                this.firstMessageInterruptionsEnabled,
                this.firstMessageMode,
                this.voicemailDetection,
                this.clientMessages,
                this.serverMessages,
                this.silenceTimeoutSeconds,
                this.maxDurationSeconds,
                this.backgroundSound,
                this.backgroundDenoisingEnabled,
                this.modelOutputInMessagesEnabled,
                this.transportConfigurations,
                this.observabilityPlan,
                this.credentials,
                this.hooks,
                this.name,
                this.voicemailMessage,
                this.endCallMessage,
                this.endCallPhrases,
                this.compliancePlan,
                this.metadata,
                this.backgroundSpeechDenoisingPlan,
                this.analysisPlan,
                this.artifactPlan,
                this.messagePlan,
                this.startSpeakingPlan,
                this.stopSpeakingPlan,
                this.monitorPlan,
                this.credentialIds,
                this.server,
                this.keypadInputPlan,
                this.id,
                this.orgId,
                this.createdAt,
                this.updatedAt);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static IdStage builder() {
        return new Builder();
    }

    public interface IdStage {
        /**
         * <p>This is the unique identifier for the assistant.</p>
         */
        OrgIdStage id(@NotNull String id);

        Builder from(Assistant other);
    }

    public interface OrgIdStage {
        /**
         * <p>This is the unique identifier for the org that this assistant belongs to.</p>
         */
        CreatedAtStage orgId(@NotNull String orgId);
    }

    public interface CreatedAtStage {
        /**
         * <p>This is the ISO 8601 date-time string of when the assistant was created.</p>
         */
        UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt);
    }

    public interface UpdatedAtStage {
        /**
         * <p>This is the ISO 8601 date-time string of when the assistant was last updated.</p>
         */
        _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt);
    }

    public interface _FinalStage {
        Assistant build();

        /**
         * <p>These are the options for the assistant's transcriber.</p>
         */
        _FinalStage transcriber(Optional<AssistantTranscriber> transcriber);

        _FinalStage transcriber(AssistantTranscriber transcriber);

        /**
         * <p>These are the options for the assistant's LLM.</p>
         */
        _FinalStage model(Optional<AssistantModel> model);

        _FinalStage model(AssistantModel model);

        /**
         * <p>These are the options for the assistant's voice.</p>
         */
        _FinalStage voice(Optional<AssistantVoice> voice);

        _FinalStage voice(AssistantVoice voice);

        /**
         * <p>This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).</p>
         * <p>If unspecified, assistant will wait for user to speak and use the model to respond once they speak.</p>
         */
        _FinalStage firstMessage(Optional<String> firstMessage);

        _FinalStage firstMessage(String firstMessage);

        _FinalStage firstMessageInterruptionsEnabled(Optional<Boolean> firstMessageInterruptionsEnabled);

        _FinalStage firstMessageInterruptionsEnabled(Boolean firstMessageInterruptionsEnabled);

        /**
         * <p>This is the mode for the first message. Default is 'assistant-speaks-first'.</p>
         * <p>Use:</p>
         * <ul>
         * <li>'assistant-speaks-first' to have the assistant speak first.</li>
         * <li>'assistant-waits-for-user' to have the assistant wait for the user to speak first.</li>
         * <li>'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (<code>assistant.model.messages</code> at call start, <code>call.messages</code> at squad transfer points).</li>
         * </ul>
         * <p>@default 'assistant-speaks-first'</p>
         */
        _FinalStage firstMessageMode(Optional<AssistantFirstMessageMode> firstMessageMode);

        _FinalStage firstMessageMode(AssistantFirstMessageMode firstMessageMode);

        /**
         * <p>These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
         * This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
         * You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.</p>
         */
        _FinalStage voicemailDetection(Optional<AssistantVoicemailDetection> voicemailDetection);

        _FinalStage voicemailDetection(AssistantVoicemailDetection voicemailDetection);

        /**
         * <p>These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.</p>
         */
        _FinalStage clientMessages(Optional<List<AssistantClientMessagesItem>> clientMessages);

        _FinalStage clientMessages(List<AssistantClientMessagesItem> clientMessages);

        /**
         * <p>These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.</p>
         */
        _FinalStage serverMessages(Optional<List<AssistantServerMessagesItem>> serverMessages);

        _FinalStage serverMessages(List<AssistantServerMessagesItem> serverMessages);

        /**
         * <p>How many seconds of silence to wait before ending the call. Defaults to 30.</p>
         * <p>@default 30</p>
         */
        _FinalStage silenceTimeoutSeconds(Optional<Double> silenceTimeoutSeconds);

        _FinalStage silenceTimeoutSeconds(Double silenceTimeoutSeconds);

        /**
         * <p>This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.</p>
         * <p>@default 600 (10 minutes)</p>
         */
        _FinalStage maxDurationSeconds(Optional<Double> maxDurationSeconds);

        _FinalStage maxDurationSeconds(Double maxDurationSeconds);

        /**
         * <p>This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
         * You can also provide a custom sound by providing a URL to an audio file.</p>
         */
        _FinalStage backgroundSound(Optional<AssistantBackgroundSound> backgroundSound);

        _FinalStage backgroundSound(AssistantBackgroundSound backgroundSound);

        /**
         * <p>This enables filtering of noise and background speech while the user is talking.</p>
         * <p>Default <code>false</code> while in beta.</p>
         * <p>@default false</p>
         */
        _FinalStage backgroundDenoisingEnabled(Optional<Boolean> backgroundDenoisingEnabled);

        _FinalStage backgroundDenoisingEnabled(Boolean backgroundDenoisingEnabled);

        /**
         * <p>This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.</p>
         * <p>Default <code>false</code> while in beta.</p>
         * <p>@default false</p>
         */
        _FinalStage modelOutputInMessagesEnabled(Optional<Boolean> modelOutputInMessagesEnabled);

        _FinalStage modelOutputInMessagesEnabled(Boolean modelOutputInMessagesEnabled);

        /**
         * <p>These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.</p>
         */
        _FinalStage transportConfigurations(Optional<List<TransportConfigurationTwilio>> transportConfigurations);

        _FinalStage transportConfigurations(List<TransportConfigurationTwilio> transportConfigurations);

        /**
         * <p>This is the plan for observability of assistant's calls.</p>
         * <p>Currently, only Langfuse is supported.</p>
         */
        _FinalStage observabilityPlan(Optional<LangfuseObservabilityPlan> observabilityPlan);

        _FinalStage observabilityPlan(LangfuseObservabilityPlan observabilityPlan);

        /**
         * <p>These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.</p>
         */
        _FinalStage credentials(Optional<List<AssistantCredentialsItem>> credentials);

        _FinalStage credentials(List<AssistantCredentialsItem> credentials);

        /**
         * <p>This is a set of actions that will be performed on certain events.</p>
         */
        _FinalStage hooks(Optional<List<AssistantHooksItem>> hooks);

        _FinalStage hooks(List<AssistantHooksItem> hooks);

        /**
         * <p>This is the name of the assistant.</p>
         * <p>This is required when you want to transfer between assistants in a call.</p>
         */
        _FinalStage name(Optional<String> name);

        _FinalStage name(String name);

        /**
         * <p>This is the message that the assistant will say if the call is forwarded to voicemail.</p>
         * <p>If unspecified, it will hang up.</p>
         */
        _FinalStage voicemailMessage(Optional<String> voicemailMessage);

        _FinalStage voicemailMessage(String voicemailMessage);

        /**
         * <p>This is the message that the assistant will say if it ends the call.</p>
         * <p>If unspecified, it will hang up without saying anything.</p>
         */
        _FinalStage endCallMessage(Optional<String> endCallMessage);

        _FinalStage endCallMessage(String endCallMessage);

        /**
         * <p>This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.</p>
         */
        _FinalStage endCallPhrases(Optional<List<String>> endCallPhrases);

        _FinalStage endCallPhrases(List<String> endCallPhrases);

        _FinalStage compliancePlan(Optional<CompliancePlan> compliancePlan);

        _FinalStage compliancePlan(CompliancePlan compliancePlan);

        /**
         * <p>This is for metadata you want to store on the assistant.</p>
         */
        _FinalStage metadata(Optional<Map<String, Object>> metadata);

        _FinalStage metadata(Map<String, Object> metadata);

        /**
         * <p>This enables filtering of noise and background speech while the user is talking.</p>
         * <p>Features:</p>
         * <ul>
         * <li>Smart denoising using Krisp</li>
         * <li>Fourier denoising</li>
         * </ul>
         * <p>Smart denoising can be combined with or used independently of Fourier denoising.</p>
         * <p>Order of precedence:</p>
         * <ul>
         * <li>Smart denoising</li>
         * <li>Fourier denoising</li>
         * </ul>
         */
        _FinalStage backgroundSpeechDenoisingPlan(
                Optional<BackgroundSpeechDenoisingPlan> backgroundSpeechDenoisingPlan);

        _FinalStage backgroundSpeechDenoisingPlan(BackgroundSpeechDenoisingPlan backgroundSpeechDenoisingPlan);

        /**
         * <p>This is the plan for analysis of assistant's calls. Stored in <code>call.analysis</code>.</p>
         */
        _FinalStage analysisPlan(Optional<AnalysisPlan> analysisPlan);

        _FinalStage analysisPlan(AnalysisPlan analysisPlan);

        /**
         * <p>This is the plan for artifacts generated during assistant's calls. Stored in <code>call.artifact</code>.</p>
         */
        _FinalStage artifactPlan(Optional<ArtifactPlan> artifactPlan);

        _FinalStage artifactPlan(ArtifactPlan artifactPlan);

        /**
         * <p>This is the plan for static predefined messages that can be spoken by the assistant during the call, like <code>idleMessages</code>.</p>
         * <p>Note: <code>firstMessage</code>, <code>voicemailMessage</code>, and <code>endCallMessage</code> are currently at the root level. They will be moved to <code>messagePlan</code> in the future, but will remain backwards compatible.</p>
         */
        _FinalStage messagePlan(Optional<MessagePlan> messagePlan);

        _FinalStage messagePlan(MessagePlan messagePlan);

        /**
         * <p>This is the plan for when the assistant should start talking.</p>
         * <p>You should configure this if you're running into these issues:</p>
         * <ul>
         * <li>The assistant is too slow to start talking after the customer is done speaking.</li>
         * <li>The assistant is too fast to start talking after the customer is done speaking.</li>
         * <li>The assistant is so fast that it's actually interrupting the customer.</li>
         * </ul>
         */
        _FinalStage startSpeakingPlan(Optional<StartSpeakingPlan> startSpeakingPlan);

        _FinalStage startSpeakingPlan(StartSpeakingPlan startSpeakingPlan);

        /**
         * <p>This is the plan for when assistant should stop talking on customer interruption.</p>
         * <p>You should configure this if you're running into these issues:</p>
         * <ul>
         * <li>The assistant is too slow to recognize customer's interruption.</li>
         * <li>The assistant is too fast to recognize customer's interruption.</li>
         * <li>The assistant is getting interrupted by phrases that are just acknowledgments.</li>
         * <li>The assistant is getting interrupted by background noises.</li>
         * <li>The assistant is not properly stopping -- it starts talking right after getting interrupted.</li>
         * </ul>
         */
        _FinalStage stopSpeakingPlan(Optional<StopSpeakingPlan> stopSpeakingPlan);

        _FinalStage stopSpeakingPlan(StopSpeakingPlan stopSpeakingPlan);

        /**
         * <p>This is the plan for real-time monitoring of the assistant's calls.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To enable live listening of the assistant's calls, set <code>monitorPlan.listenEnabled</code> to <code>true</code>.</li>
         * <li>To enable live control of the assistant's calls, set <code>monitorPlan.controlEnabled</code> to <code>true</code>.</li>
         * </ul>
         */
        _FinalStage monitorPlan(Optional<MonitorPlan> monitorPlan);

        _FinalStage monitorPlan(MonitorPlan monitorPlan);

        /**
         * <p>These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.</p>
         */
        _FinalStage credentialIds(Optional<List<String>> credentialIds);

        _FinalStage credentialIds(List<String> credentialIds);

        /**
         * <p>This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.</p>
         * <p>The order of precedence is:</p>
         * <ol>
         * <li>assistant.server.url</li>
         * <li>phoneNumber.serverUrl</li>
         * <li>org.serverUrl</li>
         * </ol>
         */
        _FinalStage server(Optional<Server> server);

        _FinalStage server(Server server);

        _FinalStage keypadInputPlan(Optional<KeypadInputPlan> keypadInputPlan);

        _FinalStage keypadInputPlan(KeypadInputPlan keypadInputPlan);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements IdStage, OrgIdStage, CreatedAtStage, UpdatedAtStage, _FinalStage {
        private String id;

        private String orgId;

        private OffsetDateTime createdAt;

        private OffsetDateTime updatedAt;

        private Optional<KeypadInputPlan> keypadInputPlan = Optional.empty();

        private Optional<Server> server = Optional.empty();

        private Optional<List<String>> credentialIds = Optional.empty();

        private Optional<MonitorPlan> monitorPlan = Optional.empty();

        private Optional<StopSpeakingPlan> stopSpeakingPlan = Optional.empty();

        private Optional<StartSpeakingPlan> startSpeakingPlan = Optional.empty();

        private Optional<MessagePlan> messagePlan = Optional.empty();

        private Optional<ArtifactPlan> artifactPlan = Optional.empty();

        private Optional<AnalysisPlan> analysisPlan = Optional.empty();

        private Optional<BackgroundSpeechDenoisingPlan> backgroundSpeechDenoisingPlan = Optional.empty();

        private Optional<Map<String, Object>> metadata = Optional.empty();

        private Optional<CompliancePlan> compliancePlan = Optional.empty();

        private Optional<List<String>> endCallPhrases = Optional.empty();

        private Optional<String> endCallMessage = Optional.empty();

        private Optional<String> voicemailMessage = Optional.empty();

        private Optional<String> name = Optional.empty();

        private Optional<List<AssistantHooksItem>> hooks = Optional.empty();

        private Optional<List<AssistantCredentialsItem>> credentials = Optional.empty();

        private Optional<LangfuseObservabilityPlan> observabilityPlan = Optional.empty();

        private Optional<List<TransportConfigurationTwilio>> transportConfigurations = Optional.empty();

        private Optional<Boolean> modelOutputInMessagesEnabled = Optional.empty();

        private Optional<Boolean> backgroundDenoisingEnabled = Optional.empty();

        private Optional<AssistantBackgroundSound> backgroundSound = Optional.empty();

        private Optional<Double> maxDurationSeconds = Optional.empty();

        private Optional<Double> silenceTimeoutSeconds = Optional.empty();

        private Optional<List<AssistantServerMessagesItem>> serverMessages = Optional.empty();

        private Optional<List<AssistantClientMessagesItem>> clientMessages = Optional.empty();

        private Optional<AssistantVoicemailDetection> voicemailDetection = Optional.empty();

        private Optional<AssistantFirstMessageMode> firstMessageMode = Optional.empty();

        private Optional<Boolean> firstMessageInterruptionsEnabled = Optional.empty();

        private Optional<String> firstMessage = Optional.empty();

        private Optional<AssistantVoice> voice = Optional.empty();

        private Optional<AssistantModel> model = Optional.empty();

        private Optional<AssistantTranscriber> transcriber = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(Assistant other) {
            transcriber(other.getTranscriber());
            model(other.getModel());
            voice(other.getVoice());
            firstMessage(other.getFirstMessage());
            firstMessageInterruptionsEnabled(other.getFirstMessageInterruptionsEnabled());
            firstMessageMode(other.getFirstMessageMode());
            voicemailDetection(other.getVoicemailDetection());
            clientMessages(other.getClientMessages());
            serverMessages(other.getServerMessages());
            silenceTimeoutSeconds(other.getSilenceTimeoutSeconds());
            maxDurationSeconds(other.getMaxDurationSeconds());
            backgroundSound(other.getBackgroundSound());
            backgroundDenoisingEnabled(other.getBackgroundDenoisingEnabled());
            modelOutputInMessagesEnabled(other.getModelOutputInMessagesEnabled());
            transportConfigurations(other.getTransportConfigurations());
            observabilityPlan(other.getObservabilityPlan());
            credentials(other.getCredentials());
            hooks(other.getHooks());
            name(other.getName());
            voicemailMessage(other.getVoicemailMessage());
            endCallMessage(other.getEndCallMessage());
            endCallPhrases(other.getEndCallPhrases());
            compliancePlan(other.getCompliancePlan());
            metadata(other.getMetadata());
            backgroundSpeechDenoisingPlan(other.getBackgroundSpeechDenoisingPlan());
            analysisPlan(other.getAnalysisPlan());
            artifactPlan(other.getArtifactPlan());
            messagePlan(other.getMessagePlan());
            startSpeakingPlan(other.getStartSpeakingPlan());
            stopSpeakingPlan(other.getStopSpeakingPlan());
            monitorPlan(other.getMonitorPlan());
            credentialIds(other.getCredentialIds());
            server(other.getServer());
            keypadInputPlan(other.getKeypadInputPlan());
            id(other.getId());
            orgId(other.getOrgId());
            createdAt(other.getCreatedAt());
            updatedAt(other.getUpdatedAt());
            return this;
        }

        /**
         * <p>This is the unique identifier for the assistant.</p>
         * <p>This is the unique identifier for the assistant.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("id")
        public OrgIdStage id(@NotNull String id) {
            this.id = Objects.requireNonNull(id, "id must not be null");
            return this;
        }

        /**
         * <p>This is the unique identifier for the org that this assistant belongs to.</p>
         * <p>This is the unique identifier for the org that this assistant belongs to.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("orgId")
        public CreatedAtStage orgId(@NotNull String orgId) {
            this.orgId = Objects.requireNonNull(orgId, "orgId must not be null");
            return this;
        }

        /**
         * <p>This is the ISO 8601 date-time string of when the assistant was created.</p>
         * <p>This is the ISO 8601 date-time string of when the assistant was created.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("createdAt")
        public UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt) {
            this.createdAt = Objects.requireNonNull(createdAt, "createdAt must not be null");
            return this;
        }

        /**
         * <p>This is the ISO 8601 date-time string of when the assistant was last updated.</p>
         * <p>This is the ISO 8601 date-time string of when the assistant was last updated.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("updatedAt")
        public _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt) {
            this.updatedAt = Objects.requireNonNull(updatedAt, "updatedAt must not be null");
            return this;
        }

        @java.lang.Override
        public _FinalStage keypadInputPlan(KeypadInputPlan keypadInputPlan) {
            this.keypadInputPlan = Optional.ofNullable(keypadInputPlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "keypadInputPlan", nulls = Nulls.SKIP)
        public _FinalStage keypadInputPlan(Optional<KeypadInputPlan> keypadInputPlan) {
            this.keypadInputPlan = keypadInputPlan;
            return this;
        }

        /**
         * <p>This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.</p>
         * <p>The order of precedence is:</p>
         * <ol>
         * <li>assistant.server.url</li>
         * <li>phoneNumber.serverUrl</li>
         * <li>org.serverUrl</li>
         * </ol>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage server(Server server) {
            this.server = Optional.ofNullable(server);
            return this;
        }

        /**
         * <p>This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.</p>
         * <p>The order of precedence is:</p>
         * <ol>
         * <li>assistant.server.url</li>
         * <li>phoneNumber.serverUrl</li>
         * <li>org.serverUrl</li>
         * </ol>
         */
        @java.lang.Override
        @JsonSetter(value = "server", nulls = Nulls.SKIP)
        public _FinalStage server(Optional<Server> server) {
            this.server = server;
            return this;
        }

        /**
         * <p>These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage credentialIds(List<String> credentialIds) {
            this.credentialIds = Optional.ofNullable(credentialIds);
            return this;
        }

        /**
         * <p>These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "credentialIds", nulls = Nulls.SKIP)
        public _FinalStage credentialIds(Optional<List<String>> credentialIds) {
            this.credentialIds = credentialIds;
            return this;
        }

        /**
         * <p>This is the plan for real-time monitoring of the assistant's calls.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To enable live listening of the assistant's calls, set <code>monitorPlan.listenEnabled</code> to <code>true</code>.</li>
         * <li>To enable live control of the assistant's calls, set <code>monitorPlan.controlEnabled</code> to <code>true</code>.</li>
         * </ul>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage monitorPlan(MonitorPlan monitorPlan) {
            this.monitorPlan = Optional.ofNullable(monitorPlan);
            return this;
        }

        /**
         * <p>This is the plan for real-time monitoring of the assistant's calls.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To enable live listening of the assistant's calls, set <code>monitorPlan.listenEnabled</code> to <code>true</code>.</li>
         * <li>To enable live control of the assistant's calls, set <code>monitorPlan.controlEnabled</code> to <code>true</code>.</li>
         * </ul>
         */
        @java.lang.Override
        @JsonSetter(value = "monitorPlan", nulls = Nulls.SKIP)
        public _FinalStage monitorPlan(Optional<MonitorPlan> monitorPlan) {
            this.monitorPlan = monitorPlan;
            return this;
        }

        /**
         * <p>This is the plan for when assistant should stop talking on customer interruption.</p>
         * <p>You should configure this if you're running into these issues:</p>
         * <ul>
         * <li>The assistant is too slow to recognize customer's interruption.</li>
         * <li>The assistant is too fast to recognize customer's interruption.</li>
         * <li>The assistant is getting interrupted by phrases that are just acknowledgments.</li>
         * <li>The assistant is getting interrupted by background noises.</li>
         * <li>The assistant is not properly stopping -- it starts talking right after getting interrupted.</li>
         * </ul>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage stopSpeakingPlan(StopSpeakingPlan stopSpeakingPlan) {
            this.stopSpeakingPlan = Optional.ofNullable(stopSpeakingPlan);
            return this;
        }

        /**
         * <p>This is the plan for when assistant should stop talking on customer interruption.</p>
         * <p>You should configure this if you're running into these issues:</p>
         * <ul>
         * <li>The assistant is too slow to recognize customer's interruption.</li>
         * <li>The assistant is too fast to recognize customer's interruption.</li>
         * <li>The assistant is getting interrupted by phrases that are just acknowledgments.</li>
         * <li>The assistant is getting interrupted by background noises.</li>
         * <li>The assistant is not properly stopping -- it starts talking right after getting interrupted.</li>
         * </ul>
         */
        @java.lang.Override
        @JsonSetter(value = "stopSpeakingPlan", nulls = Nulls.SKIP)
        public _FinalStage stopSpeakingPlan(Optional<StopSpeakingPlan> stopSpeakingPlan) {
            this.stopSpeakingPlan = stopSpeakingPlan;
            return this;
        }

        /**
         * <p>This is the plan for when the assistant should start talking.</p>
         * <p>You should configure this if you're running into these issues:</p>
         * <ul>
         * <li>The assistant is too slow to start talking after the customer is done speaking.</li>
         * <li>The assistant is too fast to start talking after the customer is done speaking.</li>
         * <li>The assistant is so fast that it's actually interrupting the customer.</li>
         * </ul>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage startSpeakingPlan(StartSpeakingPlan startSpeakingPlan) {
            this.startSpeakingPlan = Optional.ofNullable(startSpeakingPlan);
            return this;
        }

        /**
         * <p>This is the plan for when the assistant should start talking.</p>
         * <p>You should configure this if you're running into these issues:</p>
         * <ul>
         * <li>The assistant is too slow to start talking after the customer is done speaking.</li>
         * <li>The assistant is too fast to start talking after the customer is done speaking.</li>
         * <li>The assistant is so fast that it's actually interrupting the customer.</li>
         * </ul>
         */
        @java.lang.Override
        @JsonSetter(value = "startSpeakingPlan", nulls = Nulls.SKIP)
        public _FinalStage startSpeakingPlan(Optional<StartSpeakingPlan> startSpeakingPlan) {
            this.startSpeakingPlan = startSpeakingPlan;
            return this;
        }

        /**
         * <p>This is the plan for static predefined messages that can be spoken by the assistant during the call, like <code>idleMessages</code>.</p>
         * <p>Note: <code>firstMessage</code>, <code>voicemailMessage</code>, and <code>endCallMessage</code> are currently at the root level. They will be moved to <code>messagePlan</code> in the future, but will remain backwards compatible.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage messagePlan(MessagePlan messagePlan) {
            this.messagePlan = Optional.ofNullable(messagePlan);
            return this;
        }

        /**
         * <p>This is the plan for static predefined messages that can be spoken by the assistant during the call, like <code>idleMessages</code>.</p>
         * <p>Note: <code>firstMessage</code>, <code>voicemailMessage</code>, and <code>endCallMessage</code> are currently at the root level. They will be moved to <code>messagePlan</code> in the future, but will remain backwards compatible.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "messagePlan", nulls = Nulls.SKIP)
        public _FinalStage messagePlan(Optional<MessagePlan> messagePlan) {
            this.messagePlan = messagePlan;
            return this;
        }

        /**
         * <p>This is the plan for artifacts generated during assistant's calls. Stored in <code>call.artifact</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage artifactPlan(ArtifactPlan artifactPlan) {
            this.artifactPlan = Optional.ofNullable(artifactPlan);
            return this;
        }

        /**
         * <p>This is the plan for artifacts generated during assistant's calls. Stored in <code>call.artifact</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "artifactPlan", nulls = Nulls.SKIP)
        public _FinalStage artifactPlan(Optional<ArtifactPlan> artifactPlan) {
            this.artifactPlan = artifactPlan;
            return this;
        }

        /**
         * <p>This is the plan for analysis of assistant's calls. Stored in <code>call.analysis</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage analysisPlan(AnalysisPlan analysisPlan) {
            this.analysisPlan = Optional.ofNullable(analysisPlan);
            return this;
        }

        /**
         * <p>This is the plan for analysis of assistant's calls. Stored in <code>call.analysis</code>.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "analysisPlan", nulls = Nulls.SKIP)
        public _FinalStage analysisPlan(Optional<AnalysisPlan> analysisPlan) {
            this.analysisPlan = analysisPlan;
            return this;
        }

        /**
         * <p>This enables filtering of noise and background speech while the user is talking.</p>
         * <p>Features:</p>
         * <ul>
         * <li>Smart denoising using Krisp</li>
         * <li>Fourier denoising</li>
         * </ul>
         * <p>Smart denoising can be combined with or used independently of Fourier denoising.</p>
         * <p>Order of precedence:</p>
         * <ul>
         * <li>Smart denoising</li>
         * <li>Fourier denoising</li>
         * </ul>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage backgroundSpeechDenoisingPlan(BackgroundSpeechDenoisingPlan backgroundSpeechDenoisingPlan) {
            this.backgroundSpeechDenoisingPlan = Optional.ofNullable(backgroundSpeechDenoisingPlan);
            return this;
        }

        /**
         * <p>This enables filtering of noise and background speech while the user is talking.</p>
         * <p>Features:</p>
         * <ul>
         * <li>Smart denoising using Krisp</li>
         * <li>Fourier denoising</li>
         * </ul>
         * <p>Smart denoising can be combined with or used independently of Fourier denoising.</p>
         * <p>Order of precedence:</p>
         * <ul>
         * <li>Smart denoising</li>
         * <li>Fourier denoising</li>
         * </ul>
         */
        @java.lang.Override
        @JsonSetter(value = "backgroundSpeechDenoisingPlan", nulls = Nulls.SKIP)
        public _FinalStage backgroundSpeechDenoisingPlan(
                Optional<BackgroundSpeechDenoisingPlan> backgroundSpeechDenoisingPlan) {
            this.backgroundSpeechDenoisingPlan = backgroundSpeechDenoisingPlan;
            return this;
        }

        /**
         * <p>This is for metadata you want to store on the assistant.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage metadata(Map<String, Object> metadata) {
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        /**
         * <p>This is for metadata you want to store on the assistant.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "metadata", nulls = Nulls.SKIP)
        public _FinalStage metadata(Optional<Map<String, Object>> metadata) {
            this.metadata = metadata;
            return this;
        }

        @java.lang.Override
        public _FinalStage compliancePlan(CompliancePlan compliancePlan) {
            this.compliancePlan = Optional.ofNullable(compliancePlan);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "compliancePlan", nulls = Nulls.SKIP)
        public _FinalStage compliancePlan(Optional<CompliancePlan> compliancePlan) {
            this.compliancePlan = compliancePlan;
            return this;
        }

        /**
         * <p>This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage endCallPhrases(List<String> endCallPhrases) {
            this.endCallPhrases = Optional.ofNullable(endCallPhrases);
            return this;
        }

        /**
         * <p>This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "endCallPhrases", nulls = Nulls.SKIP)
        public _FinalStage endCallPhrases(Optional<List<String>> endCallPhrases) {
            this.endCallPhrases = endCallPhrases;
            return this;
        }

        /**
         * <p>This is the message that the assistant will say if it ends the call.</p>
         * <p>If unspecified, it will hang up without saying anything.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage endCallMessage(String endCallMessage) {
            this.endCallMessage = Optional.ofNullable(endCallMessage);
            return this;
        }

        /**
         * <p>This is the message that the assistant will say if it ends the call.</p>
         * <p>If unspecified, it will hang up without saying anything.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "endCallMessage", nulls = Nulls.SKIP)
        public _FinalStage endCallMessage(Optional<String> endCallMessage) {
            this.endCallMessage = endCallMessage;
            return this;
        }

        /**
         * <p>This is the message that the assistant will say if the call is forwarded to voicemail.</p>
         * <p>If unspecified, it will hang up.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage voicemailMessage(String voicemailMessage) {
            this.voicemailMessage = Optional.ofNullable(voicemailMessage);
            return this;
        }

        /**
         * <p>This is the message that the assistant will say if the call is forwarded to voicemail.</p>
         * <p>If unspecified, it will hang up.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "voicemailMessage", nulls = Nulls.SKIP)
        public _FinalStage voicemailMessage(Optional<String> voicemailMessage) {
            this.voicemailMessage = voicemailMessage;
            return this;
        }

        /**
         * <p>This is the name of the assistant.</p>
         * <p>This is required when you want to transfer between assistants in a call.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage name(String name) {
            this.name = Optional.ofNullable(name);
            return this;
        }

        /**
         * <p>This is the name of the assistant.</p>
         * <p>This is required when you want to transfer between assistants in a call.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "name", nulls = Nulls.SKIP)
        public _FinalStage name(Optional<String> name) {
            this.name = name;
            return this;
        }

        /**
         * <p>This is a set of actions that will be performed on certain events.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage hooks(List<AssistantHooksItem> hooks) {
            this.hooks = Optional.ofNullable(hooks);
            return this;
        }

        /**
         * <p>This is a set of actions that will be performed on certain events.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "hooks", nulls = Nulls.SKIP)
        public _FinalStage hooks(Optional<List<AssistantHooksItem>> hooks) {
            this.hooks = hooks;
            return this;
        }

        /**
         * <p>These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage credentials(List<AssistantCredentialsItem> credentials) {
            this.credentials = Optional.ofNullable(credentials);
            return this;
        }

        /**
         * <p>These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "credentials", nulls = Nulls.SKIP)
        public _FinalStage credentials(Optional<List<AssistantCredentialsItem>> credentials) {
            this.credentials = credentials;
            return this;
        }

        /**
         * <p>This is the plan for observability of assistant's calls.</p>
         * <p>Currently, only Langfuse is supported.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage observabilityPlan(LangfuseObservabilityPlan observabilityPlan) {
            this.observabilityPlan = Optional.ofNullable(observabilityPlan);
            return this;
        }

        /**
         * <p>This is the plan for observability of assistant's calls.</p>
         * <p>Currently, only Langfuse is supported.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "observabilityPlan", nulls = Nulls.SKIP)
        public _FinalStage observabilityPlan(Optional<LangfuseObservabilityPlan> observabilityPlan) {
            this.observabilityPlan = observabilityPlan;
            return this;
        }

        /**
         * <p>These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage transportConfigurations(List<TransportConfigurationTwilio> transportConfigurations) {
            this.transportConfigurations = Optional.ofNullable(transportConfigurations);
            return this;
        }

        /**
         * <p>These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "transportConfigurations", nulls = Nulls.SKIP)
        public _FinalStage transportConfigurations(
                Optional<List<TransportConfigurationTwilio>> transportConfigurations) {
            this.transportConfigurations = transportConfigurations;
            return this;
        }

        /**
         * <p>This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.</p>
         * <p>Default <code>false</code> while in beta.</p>
         * <p>@default false</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage modelOutputInMessagesEnabled(Boolean modelOutputInMessagesEnabled) {
            this.modelOutputInMessagesEnabled = Optional.ofNullable(modelOutputInMessagesEnabled);
            return this;
        }

        /**
         * <p>This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.</p>
         * <p>Default <code>false</code> while in beta.</p>
         * <p>@default false</p>
         */
        @java.lang.Override
        @JsonSetter(value = "modelOutputInMessagesEnabled", nulls = Nulls.SKIP)
        public _FinalStage modelOutputInMessagesEnabled(Optional<Boolean> modelOutputInMessagesEnabled) {
            this.modelOutputInMessagesEnabled = modelOutputInMessagesEnabled;
            return this;
        }

        /**
         * <p>This enables filtering of noise and background speech while the user is talking.</p>
         * <p>Default <code>false</code> while in beta.</p>
         * <p>@default false</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage backgroundDenoisingEnabled(Boolean backgroundDenoisingEnabled) {
            this.backgroundDenoisingEnabled = Optional.ofNullable(backgroundDenoisingEnabled);
            return this;
        }

        /**
         * <p>This enables filtering of noise and background speech while the user is talking.</p>
         * <p>Default <code>false</code> while in beta.</p>
         * <p>@default false</p>
         */
        @java.lang.Override
        @JsonSetter(value = "backgroundDenoisingEnabled", nulls = Nulls.SKIP)
        public _FinalStage backgroundDenoisingEnabled(Optional<Boolean> backgroundDenoisingEnabled) {
            this.backgroundDenoisingEnabled = backgroundDenoisingEnabled;
            return this;
        }

        /**
         * <p>This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
         * You can also provide a custom sound by providing a URL to an audio file.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage backgroundSound(AssistantBackgroundSound backgroundSound) {
            this.backgroundSound = Optional.ofNullable(backgroundSound);
            return this;
        }

        /**
         * <p>This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
         * You can also provide a custom sound by providing a URL to an audio file.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "backgroundSound", nulls = Nulls.SKIP)
        public _FinalStage backgroundSound(Optional<AssistantBackgroundSound> backgroundSound) {
            this.backgroundSound = backgroundSound;
            return this;
        }

        /**
         * <p>This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.</p>
         * <p>@default 600 (10 minutes)</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage maxDurationSeconds(Double maxDurationSeconds) {
            this.maxDurationSeconds = Optional.ofNullable(maxDurationSeconds);
            return this;
        }

        /**
         * <p>This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.</p>
         * <p>@default 600 (10 minutes)</p>
         */
        @java.lang.Override
        @JsonSetter(value = "maxDurationSeconds", nulls = Nulls.SKIP)
        public _FinalStage maxDurationSeconds(Optional<Double> maxDurationSeconds) {
            this.maxDurationSeconds = maxDurationSeconds;
            return this;
        }

        /**
         * <p>How many seconds of silence to wait before ending the call. Defaults to 30.</p>
         * <p>@default 30</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage silenceTimeoutSeconds(Double silenceTimeoutSeconds) {
            this.silenceTimeoutSeconds = Optional.ofNullable(silenceTimeoutSeconds);
            return this;
        }

        /**
         * <p>How many seconds of silence to wait before ending the call. Defaults to 30.</p>
         * <p>@default 30</p>
         */
        @java.lang.Override
        @JsonSetter(value = "silenceTimeoutSeconds", nulls = Nulls.SKIP)
        public _FinalStage silenceTimeoutSeconds(Optional<Double> silenceTimeoutSeconds) {
            this.silenceTimeoutSeconds = silenceTimeoutSeconds;
            return this;
        }

        /**
         * <p>These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage serverMessages(List<AssistantServerMessagesItem> serverMessages) {
            this.serverMessages = Optional.ofNullable(serverMessages);
            return this;
        }

        /**
         * <p>These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "serverMessages", nulls = Nulls.SKIP)
        public _FinalStage serverMessages(Optional<List<AssistantServerMessagesItem>> serverMessages) {
            this.serverMessages = serverMessages;
            return this;
        }

        /**
         * <p>These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage clientMessages(List<AssistantClientMessagesItem> clientMessages) {
            this.clientMessages = Optional.ofNullable(clientMessages);
            return this;
        }

        /**
         * <p>These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "clientMessages", nulls = Nulls.SKIP)
        public _FinalStage clientMessages(Optional<List<AssistantClientMessagesItem>> clientMessages) {
            this.clientMessages = clientMessages;
            return this;
        }

        /**
         * <p>These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
         * This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
         * You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage voicemailDetection(AssistantVoicemailDetection voicemailDetection) {
            this.voicemailDetection = Optional.ofNullable(voicemailDetection);
            return this;
        }

        /**
         * <p>These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
         * This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
         * You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "voicemailDetection", nulls = Nulls.SKIP)
        public _FinalStage voicemailDetection(Optional<AssistantVoicemailDetection> voicemailDetection) {
            this.voicemailDetection = voicemailDetection;
            return this;
        }

        /**
         * <p>This is the mode for the first message. Default is 'assistant-speaks-first'.</p>
         * <p>Use:</p>
         * <ul>
         * <li>'assistant-speaks-first' to have the assistant speak first.</li>
         * <li>'assistant-waits-for-user' to have the assistant wait for the user to speak first.</li>
         * <li>'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (<code>assistant.model.messages</code> at call start, <code>call.messages</code> at squad transfer points).</li>
         * </ul>
         * <p>@default 'assistant-speaks-first'</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage firstMessageMode(AssistantFirstMessageMode firstMessageMode) {
            this.firstMessageMode = Optional.ofNullable(firstMessageMode);
            return this;
        }

        /**
         * <p>This is the mode for the first message. Default is 'assistant-speaks-first'.</p>
         * <p>Use:</p>
         * <ul>
         * <li>'assistant-speaks-first' to have the assistant speak first.</li>
         * <li>'assistant-waits-for-user' to have the assistant wait for the user to speak first.</li>
         * <li>'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (<code>assistant.model.messages</code> at call start, <code>call.messages</code> at squad transfer points).</li>
         * </ul>
         * <p>@default 'assistant-speaks-first'</p>
         */
        @java.lang.Override
        @JsonSetter(value = "firstMessageMode", nulls = Nulls.SKIP)
        public _FinalStage firstMessageMode(Optional<AssistantFirstMessageMode> firstMessageMode) {
            this.firstMessageMode = firstMessageMode;
            return this;
        }

        @java.lang.Override
        public _FinalStage firstMessageInterruptionsEnabled(Boolean firstMessageInterruptionsEnabled) {
            this.firstMessageInterruptionsEnabled = Optional.ofNullable(firstMessageInterruptionsEnabled);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "firstMessageInterruptionsEnabled", nulls = Nulls.SKIP)
        public _FinalStage firstMessageInterruptionsEnabled(Optional<Boolean> firstMessageInterruptionsEnabled) {
            this.firstMessageInterruptionsEnabled = firstMessageInterruptionsEnabled;
            return this;
        }

        /**
         * <p>This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).</p>
         * <p>If unspecified, assistant will wait for user to speak and use the model to respond once they speak.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage firstMessage(String firstMessage) {
            this.firstMessage = Optional.ofNullable(firstMessage);
            return this;
        }

        /**
         * <p>This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).</p>
         * <p>If unspecified, assistant will wait for user to speak and use the model to respond once they speak.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "firstMessage", nulls = Nulls.SKIP)
        public _FinalStage firstMessage(Optional<String> firstMessage) {
            this.firstMessage = firstMessage;
            return this;
        }

        /**
         * <p>These are the options for the assistant's voice.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage voice(AssistantVoice voice) {
            this.voice = Optional.ofNullable(voice);
            return this;
        }

        /**
         * <p>These are the options for the assistant's voice.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "voice", nulls = Nulls.SKIP)
        public _FinalStage voice(Optional<AssistantVoice> voice) {
            this.voice = voice;
            return this;
        }

        /**
         * <p>These are the options for the assistant's LLM.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage model(AssistantModel model) {
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * <p>These are the options for the assistant's LLM.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "model", nulls = Nulls.SKIP)
        public _FinalStage model(Optional<AssistantModel> model) {
            this.model = model;
            return this;
        }

        /**
         * <p>These are the options for the assistant's transcriber.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage transcriber(AssistantTranscriber transcriber) {
            this.transcriber = Optional.ofNullable(transcriber);
            return this;
        }

        /**
         * <p>These are the options for the assistant's transcriber.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "transcriber", nulls = Nulls.SKIP)
        public _FinalStage transcriber(Optional<AssistantTranscriber> transcriber) {
            this.transcriber = transcriber;
            return this;
        }

        @java.lang.Override
        public Assistant build() {
            return new Assistant(
                    transcriber,
                    model,
                    voice,
                    firstMessage,
                    firstMessageInterruptionsEnabled,
                    firstMessageMode,
                    voicemailDetection,
                    clientMessages,
                    serverMessages,
                    silenceTimeoutSeconds,
                    maxDurationSeconds,
                    backgroundSound,
                    backgroundDenoisingEnabled,
                    modelOutputInMessagesEnabled,
                    transportConfigurations,
                    observabilityPlan,
                    credentials,
                    hooks,
                    name,
                    voicemailMessage,
                    endCallMessage,
                    endCallPhrases,
                    compliancePlan,
                    metadata,
                    backgroundSpeechDenoisingPlan,
                    analysisPlan,
                    artifactPlan,
                    messagePlan,
                    startSpeakingPlan,
                    stopSpeakingPlan,
                    monitorPlan,
                    credentialIds,
                    server,
                    keypadInputPlan,
                    id,
                    orgId,
                    createdAt,
                    updatedAt,
                    additionalProperties);
        }
    }
}
