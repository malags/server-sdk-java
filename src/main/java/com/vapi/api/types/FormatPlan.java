/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = FormatPlan.Builder.class)
public final class FormatPlan {
    private final Optional<Boolean> enabled;

    private final Optional<Double> numberToDigitsCutoff;

    private final Optional<List<FormatPlanReplacementsItem>> replacements;

    private final Optional<List<FormatPlanFormattersEnabledItem>> formattersEnabled;

    private final Map<String, Object> additionalProperties;

    private FormatPlan(
            Optional<Boolean> enabled,
            Optional<Double> numberToDigitsCutoff,
            Optional<List<FormatPlanReplacementsItem>> replacements,
            Optional<List<FormatPlanFormattersEnabledItem>> formattersEnabled,
            Map<String, Object> additionalProperties) {
        this.enabled = enabled;
        this.numberToDigitsCutoff = numberToDigitsCutoff;
        this.replacements = replacements;
        this.formattersEnabled = formattersEnabled;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return This determines whether the chunk is formatted before being sent to the voice provider. This helps with enunciation. This includes phone numbers, emails and addresses. Default <code>true</code>.
     * <p>Usage:</p>
     * <ul>
     * <li>To rely on the voice provider's formatting logic, set this to <code>false</code>.</li>
     * </ul>
     * <p>If <code>voice.chunkPlan.enabled</code> is <code>false</code>, this is automatically <code>false</code> since there's no chunk to format.</p>
     * <p>@default true</p>
     */
    @JsonProperty("enabled")
    public Optional<Boolean> getEnabled() {
        return enabled;
    }

    /**
     * @return This is the cutoff after which a number is converted to individual digits instead of being spoken as words.
     * <p>Example:</p>
     * <ul>
     * <li>If cutoff 2025, &quot;12345&quot; is converted to &quot;1 2 3 4 5&quot; while &quot;1200&quot; is converted to &quot;twelve hundred&quot;.</li>
     * </ul>
     * <p>Usage:</p>
     * <ul>
     * <li>If your use case doesn't involve IDs like zip codes, set this to a high value.</li>
     * <li>If your use case involves IDs that are shorter than 5 digits, set this to a lower value.</li>
     * </ul>
     * <p>@default 2025</p>
     */
    @JsonProperty("numberToDigitsCutoff")
    public Optional<Double> getNumberToDigitsCutoff() {
        return numberToDigitsCutoff;
    }

    /**
     * @return These are the custom replacements you can make to the chunk before it is sent to the voice provider.
     * <p>Usage:</p>
     * <ul>
     * <li>To replace a specific word or phrase with a different word or phrase, use the <code>ExactReplacement</code> type. Eg. <code>{ type: 'exact', key: 'hello', value: 'hi' }</code></li>
     * <li>To replace a word or phrase that matches a pattern, use the <code>RegexReplacement</code> type. Eg. <code>{ type: 'regex', regex: '\\b[a-zA-Z]{5}\\b', value: 'hi' }</code></li>
     * </ul>
     * <p>@default []</p>
     */
    @JsonProperty("replacements")
    public Optional<List<FormatPlanReplacementsItem>> getReplacements() {
        return replacements;
    }

    /**
     * @return List of formatters to apply. If not provided, all default formatters will be applied.
     * If provided, only the specified formatters will be applied.
     * Note: Some essential formatters like angle bracket removal will always be applied.
     * @default undefined
     */
    @JsonProperty("formattersEnabled")
    public Optional<List<FormatPlanFormattersEnabledItem>> getFormattersEnabled() {
        return formattersEnabled;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof FormatPlan && equalTo((FormatPlan) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(FormatPlan other) {
        return enabled.equals(other.enabled)
                && numberToDigitsCutoff.equals(other.numberToDigitsCutoff)
                && replacements.equals(other.replacements)
                && formattersEnabled.equals(other.formattersEnabled);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.enabled, this.numberToDigitsCutoff, this.replacements, this.formattersEnabled);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Boolean> enabled = Optional.empty();

        private Optional<Double> numberToDigitsCutoff = Optional.empty();

        private Optional<List<FormatPlanReplacementsItem>> replacements = Optional.empty();

        private Optional<List<FormatPlanFormattersEnabledItem>> formattersEnabled = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(FormatPlan other) {
            enabled(other.getEnabled());
            numberToDigitsCutoff(other.getNumberToDigitsCutoff());
            replacements(other.getReplacements());
            formattersEnabled(other.getFormattersEnabled());
            return this;
        }

        /**
         * <p>This determines whether the chunk is formatted before being sent to the voice provider. This helps with enunciation. This includes phone numbers, emails and addresses. Default <code>true</code>.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To rely on the voice provider's formatting logic, set this to <code>false</code>.</li>
         * </ul>
         * <p>If <code>voice.chunkPlan.enabled</code> is <code>false</code>, this is automatically <code>false</code> since there's no chunk to format.</p>
         * <p>@default true</p>
         */
        @JsonSetter(value = "enabled", nulls = Nulls.SKIP)
        public Builder enabled(Optional<Boolean> enabled) {
            this.enabled = enabled;
            return this;
        }

        public Builder enabled(Boolean enabled) {
            this.enabled = Optional.ofNullable(enabled);
            return this;
        }

        /**
         * <p>This is the cutoff after which a number is converted to individual digits instead of being spoken as words.</p>
         * <p>Example:</p>
         * <ul>
         * <li>If cutoff 2025, &quot;12345&quot; is converted to &quot;1 2 3 4 5&quot; while &quot;1200&quot; is converted to &quot;twelve hundred&quot;.</li>
         * </ul>
         * <p>Usage:</p>
         * <ul>
         * <li>If your use case doesn't involve IDs like zip codes, set this to a high value.</li>
         * <li>If your use case involves IDs that are shorter than 5 digits, set this to a lower value.</li>
         * </ul>
         * <p>@default 2025</p>
         */
        @JsonSetter(value = "numberToDigitsCutoff", nulls = Nulls.SKIP)
        public Builder numberToDigitsCutoff(Optional<Double> numberToDigitsCutoff) {
            this.numberToDigitsCutoff = numberToDigitsCutoff;
            return this;
        }

        public Builder numberToDigitsCutoff(Double numberToDigitsCutoff) {
            this.numberToDigitsCutoff = Optional.ofNullable(numberToDigitsCutoff);
            return this;
        }

        /**
         * <p>These are the custom replacements you can make to the chunk before it is sent to the voice provider.</p>
         * <p>Usage:</p>
         * <ul>
         * <li>To replace a specific word or phrase with a different word or phrase, use the <code>ExactReplacement</code> type. Eg. <code>{ type: 'exact', key: 'hello', value: 'hi' }</code></li>
         * <li>To replace a word or phrase that matches a pattern, use the <code>RegexReplacement</code> type. Eg. <code>{ type: 'regex', regex: '\\b[a-zA-Z]{5}\\b', value: 'hi' }</code></li>
         * </ul>
         * <p>@default []</p>
         */
        @JsonSetter(value = "replacements", nulls = Nulls.SKIP)
        public Builder replacements(Optional<List<FormatPlanReplacementsItem>> replacements) {
            this.replacements = replacements;
            return this;
        }

        public Builder replacements(List<FormatPlanReplacementsItem> replacements) {
            this.replacements = Optional.ofNullable(replacements);
            return this;
        }

        /**
         * <p>List of formatters to apply. If not provided, all default formatters will be applied.
         * If provided, only the specified formatters will be applied.
         * Note: Some essential formatters like angle bracket removal will always be applied.
         * @default undefined</p>
         */
        @JsonSetter(value = "formattersEnabled", nulls = Nulls.SKIP)
        public Builder formattersEnabled(Optional<List<FormatPlanFormattersEnabledItem>> formattersEnabled) {
            this.formattersEnabled = formattersEnabled;
            return this;
        }

        public Builder formattersEnabled(List<FormatPlanFormattersEnabledItem> formattersEnabled) {
            this.formattersEnabled = Optional.ofNullable(formattersEnabled);
            return this;
        }

        public FormatPlan build() {
            return new FormatPlan(enabled, numberToDigitsCutoff, replacements, formattersEnabled, additionalProperties);
        }
    }
}
