/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = TranscriptionEndpointingPlan.Builder.class)
public final class TranscriptionEndpointingPlan {
    private final Optional<Double> onPunctuationSeconds;

    private final Optional<Double> onNoPunctuationSeconds;

    private final Optional<Double> onNumberSeconds;

    private final Map<String, Object> additionalProperties;

    private TranscriptionEndpointingPlan(
            Optional<Double> onPunctuationSeconds,
            Optional<Double> onNoPunctuationSeconds,
            Optional<Double> onNumberSeconds,
            Map<String, Object> additionalProperties) {
        this.onPunctuationSeconds = onPunctuationSeconds;
        this.onNoPunctuationSeconds = onNoPunctuationSeconds;
        this.onNumberSeconds = onNumberSeconds;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The minimum number of seconds to wait after transcription ending with punctuation before sending a request to the model. Defaults to 0.1.
     * <p>This setting exists because the transcriber punctuates the transcription when it's more confident that customer has completed a thought.</p>
     * <p>@default 0.1</p>
     */
    @JsonProperty("onPunctuationSeconds")
    public Optional<Double> getOnPunctuationSeconds() {
        return onPunctuationSeconds;
    }

    /**
     * @return The minimum number of seconds to wait after transcription ending without punctuation before sending a request to the model. Defaults to 1.5.
     * <p>This setting exists to catch the cases where the transcriber was not confident enough to punctuate the transcription, but the customer is done and has been silent for a long time.</p>
     * <p>@default 1.5</p>
     */
    @JsonProperty("onNoPunctuationSeconds")
    public Optional<Double> getOnNoPunctuationSeconds() {
        return onNoPunctuationSeconds;
    }

    /**
     * @return The minimum number of seconds to wait after transcription ending with a number before sending a request to the model. Defaults to 0.4.
     * <p>This setting exists because the transcriber will sometimes punctuate the transcription ending with a number, even though the customer hasn't uttered the full number. This happens commonly for long numbers when the customer reads the number in chunks.</p>
     * <p>@default 0.5</p>
     */
    @JsonProperty("onNumberSeconds")
    public Optional<Double> getOnNumberSeconds() {
        return onNumberSeconds;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof TranscriptionEndpointingPlan && equalTo((TranscriptionEndpointingPlan) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(TranscriptionEndpointingPlan other) {
        return onPunctuationSeconds.equals(other.onPunctuationSeconds)
                && onNoPunctuationSeconds.equals(other.onNoPunctuationSeconds)
                && onNumberSeconds.equals(other.onNumberSeconds);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.onPunctuationSeconds, this.onNoPunctuationSeconds, this.onNumberSeconds);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Double> onPunctuationSeconds = Optional.empty();

        private Optional<Double> onNoPunctuationSeconds = Optional.empty();

        private Optional<Double> onNumberSeconds = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(TranscriptionEndpointingPlan other) {
            onPunctuationSeconds(other.getOnPunctuationSeconds());
            onNoPunctuationSeconds(other.getOnNoPunctuationSeconds());
            onNumberSeconds(other.getOnNumberSeconds());
            return this;
        }

        @JsonSetter(value = "onPunctuationSeconds", nulls = Nulls.SKIP)
        public Builder onPunctuationSeconds(Optional<Double> onPunctuationSeconds) {
            this.onPunctuationSeconds = onPunctuationSeconds;
            return this;
        }

        public Builder onPunctuationSeconds(Double onPunctuationSeconds) {
            this.onPunctuationSeconds = Optional.ofNullable(onPunctuationSeconds);
            return this;
        }

        @JsonSetter(value = "onNoPunctuationSeconds", nulls = Nulls.SKIP)
        public Builder onNoPunctuationSeconds(Optional<Double> onNoPunctuationSeconds) {
            this.onNoPunctuationSeconds = onNoPunctuationSeconds;
            return this;
        }

        public Builder onNoPunctuationSeconds(Double onNoPunctuationSeconds) {
            this.onNoPunctuationSeconds = Optional.ofNullable(onNoPunctuationSeconds);
            return this;
        }

        @JsonSetter(value = "onNumberSeconds", nulls = Nulls.SKIP)
        public Builder onNumberSeconds(Optional<Double> onNumberSeconds) {
            this.onNumberSeconds = onNumberSeconds;
            return this;
        }

        public Builder onNumberSeconds(Double onNumberSeconds) {
            this.onNumberSeconds = Optional.ofNullable(onNumberSeconds);
            return this;
        }

        public TranscriptionEndpointingPlan build() {
            return new TranscriptionEndpointingPlan(
                    onPunctuationSeconds, onNoPunctuationSeconds, onNumberSeconds, additionalProperties);
        }
    }
}
