/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = TransferCallTool.Builder.class)
public final class TransferCallTool {
    private final Optional<List<TransferCallToolMessagesItem>> messages;

    private final Optional<List<TransferCallToolDestinationsItem>> destinations;

    private final String id;

    private final String orgId;

    private final OffsetDateTime createdAt;

    private final OffsetDateTime updatedAt;

    private final Optional<OpenAiFunction> function;

    private final Map<String, Object> additionalProperties;

    private TransferCallTool(
            Optional<List<TransferCallToolMessagesItem>> messages,
            Optional<List<TransferCallToolDestinationsItem>> destinations,
            String id,
            String orgId,
            OffsetDateTime createdAt,
            OffsetDateTime updatedAt,
            Optional<OpenAiFunction> function,
            Map<String, Object> additionalProperties) {
        this.messages = messages;
        this.destinations = destinations;
        this.id = id;
        this.orgId = orgId;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.function = function;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return These are the messages that will be spoken to the user as the tool is running.
     * <p>For some tools, this is auto-filled based on special fields like <code>tool.destinations</code>. For others like the function tool, these can be custom configured.</p>
     */
    @JsonProperty("messages")
    public Optional<List<TransferCallToolMessagesItem>> getMessages() {
        return messages;
    }

    /**
     * @return These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
     */
    @JsonProperty("destinations")
    public Optional<List<TransferCallToolDestinationsItem>> getDestinations() {
        return destinations;
    }

    /**
     * @return This is the unique identifier for the tool.
     */
    @JsonProperty("id")
    public String getId() {
        return id;
    }

    /**
     * @return This is the unique identifier for the organization that this tool belongs to.
     */
    @JsonProperty("orgId")
    public String getOrgId() {
        return orgId;
    }

    /**
     * @return This is the ISO 8601 date-time string of when the tool was created.
     */
    @JsonProperty("createdAt")
    public OffsetDateTime getCreatedAt() {
        return createdAt;
    }

    /**
     * @return This is the ISO 8601 date-time string of when the tool was last updated.
     */
    @JsonProperty("updatedAt")
    public OffsetDateTime getUpdatedAt() {
        return updatedAt;
    }

    /**
     * @return This is the function definition of the tool.
     * <p>For <code>endCall</code>, <code>transferCall</code>, and <code>dtmf</code> tools, this is auto-filled based on tool-specific fields like <code>tool.destinations</code>. But, even in those cases, you can provide a custom function definition for advanced use cases.</p>
     * <p>An example of an advanced use case is if you want to customize the message that's spoken for <code>endCall</code> tool. You can specify a function where it returns an argument &quot;reason&quot;. Then, in <code>messages</code> array, you can have many &quot;request-complete&quot; messages. One of these messages will be triggered if the <code>messages[].conditions</code> matches the &quot;reason&quot; argument.</p>
     */
    @JsonProperty("function")
    public Optional<OpenAiFunction> getFunction() {
        return function;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof TransferCallTool && equalTo((TransferCallTool) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(TransferCallTool other) {
        return messages.equals(other.messages)
                && destinations.equals(other.destinations)
                && id.equals(other.id)
                && orgId.equals(other.orgId)
                && createdAt.equals(other.createdAt)
                && updatedAt.equals(other.updatedAt)
                && function.equals(other.function);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.messages, this.destinations, this.id, this.orgId, this.createdAt, this.updatedAt, this.function);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static IdStage builder() {
        return new Builder();
    }

    public interface IdStage {
        /**
         * <p>This is the unique identifier for the tool.</p>
         */
        OrgIdStage id(@NotNull String id);

        Builder from(TransferCallTool other);
    }

    public interface OrgIdStage {
        /**
         * <p>This is the unique identifier for the organization that this tool belongs to.</p>
         */
        CreatedAtStage orgId(@NotNull String orgId);
    }

    public interface CreatedAtStage {
        /**
         * <p>This is the ISO 8601 date-time string of when the tool was created.</p>
         */
        UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt);
    }

    public interface UpdatedAtStage {
        /**
         * <p>This is the ISO 8601 date-time string of when the tool was last updated.</p>
         */
        _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt);
    }

    public interface _FinalStage {
        TransferCallTool build();

        /**
         * <p>These are the messages that will be spoken to the user as the tool is running.</p>
         * <p>For some tools, this is auto-filled based on special fields like <code>tool.destinations</code>. For others like the function tool, these can be custom configured.</p>
         */
        _FinalStage messages(Optional<List<TransferCallToolMessagesItem>> messages);

        _FinalStage messages(List<TransferCallToolMessagesItem> messages);

        /**
         * <p>These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.</p>
         */
        _FinalStage destinations(Optional<List<TransferCallToolDestinationsItem>> destinations);

        _FinalStage destinations(List<TransferCallToolDestinationsItem> destinations);

        /**
         * <p>This is the function definition of the tool.</p>
         * <p>For <code>endCall</code>, <code>transferCall</code>, and <code>dtmf</code> tools, this is auto-filled based on tool-specific fields like <code>tool.destinations</code>. But, even in those cases, you can provide a custom function definition for advanced use cases.</p>
         * <p>An example of an advanced use case is if you want to customize the message that's spoken for <code>endCall</code> tool. You can specify a function where it returns an argument &quot;reason&quot;. Then, in <code>messages</code> array, you can have many &quot;request-complete&quot; messages. One of these messages will be triggered if the <code>messages[].conditions</code> matches the &quot;reason&quot; argument.</p>
         */
        _FinalStage function(Optional<OpenAiFunction> function);

        _FinalStage function(OpenAiFunction function);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements IdStage, OrgIdStage, CreatedAtStage, UpdatedAtStage, _FinalStage {
        private String id;

        private String orgId;

        private OffsetDateTime createdAt;

        private OffsetDateTime updatedAt;

        private Optional<OpenAiFunction> function = Optional.empty();

        private Optional<List<TransferCallToolDestinationsItem>> destinations = Optional.empty();

        private Optional<List<TransferCallToolMessagesItem>> messages = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(TransferCallTool other) {
            messages(other.getMessages());
            destinations(other.getDestinations());
            id(other.getId());
            orgId(other.getOrgId());
            createdAt(other.getCreatedAt());
            updatedAt(other.getUpdatedAt());
            function(other.getFunction());
            return this;
        }

        /**
         * <p>This is the unique identifier for the tool.</p>
         * <p>This is the unique identifier for the tool.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("id")
        public OrgIdStage id(@NotNull String id) {
            this.id = Objects.requireNonNull(id, "id must not be null");
            return this;
        }

        /**
         * <p>This is the unique identifier for the organization that this tool belongs to.</p>
         * <p>This is the unique identifier for the organization that this tool belongs to.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("orgId")
        public CreatedAtStage orgId(@NotNull String orgId) {
            this.orgId = Objects.requireNonNull(orgId, "orgId must not be null");
            return this;
        }

        /**
         * <p>This is the ISO 8601 date-time string of when the tool was created.</p>
         * <p>This is the ISO 8601 date-time string of when the tool was created.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("createdAt")
        public UpdatedAtStage createdAt(@NotNull OffsetDateTime createdAt) {
            this.createdAt = Objects.requireNonNull(createdAt, "createdAt must not be null");
            return this;
        }

        /**
         * <p>This is the ISO 8601 date-time string of when the tool was last updated.</p>
         * <p>This is the ISO 8601 date-time string of when the tool was last updated.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("updatedAt")
        public _FinalStage updatedAt(@NotNull OffsetDateTime updatedAt) {
            this.updatedAt = Objects.requireNonNull(updatedAt, "updatedAt must not be null");
            return this;
        }

        /**
         * <p>This is the function definition of the tool.</p>
         * <p>For <code>endCall</code>, <code>transferCall</code>, and <code>dtmf</code> tools, this is auto-filled based on tool-specific fields like <code>tool.destinations</code>. But, even in those cases, you can provide a custom function definition for advanced use cases.</p>
         * <p>An example of an advanced use case is if you want to customize the message that's spoken for <code>endCall</code> tool. You can specify a function where it returns an argument &quot;reason&quot;. Then, in <code>messages</code> array, you can have many &quot;request-complete&quot; messages. One of these messages will be triggered if the <code>messages[].conditions</code> matches the &quot;reason&quot; argument.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage function(OpenAiFunction function) {
            this.function = Optional.ofNullable(function);
            return this;
        }

        /**
         * <p>This is the function definition of the tool.</p>
         * <p>For <code>endCall</code>, <code>transferCall</code>, and <code>dtmf</code> tools, this is auto-filled based on tool-specific fields like <code>tool.destinations</code>. But, even in those cases, you can provide a custom function definition for advanced use cases.</p>
         * <p>An example of an advanced use case is if you want to customize the message that's spoken for <code>endCall</code> tool. You can specify a function where it returns an argument &quot;reason&quot;. Then, in <code>messages</code> array, you can have many &quot;request-complete&quot; messages. One of these messages will be triggered if the <code>messages[].conditions</code> matches the &quot;reason&quot; argument.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "function", nulls = Nulls.SKIP)
        public _FinalStage function(Optional<OpenAiFunction> function) {
            this.function = function;
            return this;
        }

        /**
         * <p>These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage destinations(List<TransferCallToolDestinationsItem> destinations) {
            this.destinations = Optional.ofNullable(destinations);
            return this;
        }

        /**
         * <p>These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "destinations", nulls = Nulls.SKIP)
        public _FinalStage destinations(Optional<List<TransferCallToolDestinationsItem>> destinations) {
            this.destinations = destinations;
            return this;
        }

        /**
         * <p>These are the messages that will be spoken to the user as the tool is running.</p>
         * <p>For some tools, this is auto-filled based on special fields like <code>tool.destinations</code>. For others like the function tool, these can be custom configured.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage messages(List<TransferCallToolMessagesItem> messages) {
            this.messages = Optional.ofNullable(messages);
            return this;
        }

        /**
         * <p>These are the messages that will be spoken to the user as the tool is running.</p>
         * <p>For some tools, this is auto-filled based on special fields like <code>tool.destinations</code>. For others like the function tool, these can be custom configured.</p>
         */
        @java.lang.Override
        @JsonSetter(value = "messages", nulls = Nulls.SKIP)
        public _FinalStage messages(Optional<List<TransferCallToolMessagesItem>> messages) {
            this.messages = messages;
            return this;
        }

        @java.lang.Override
        public TransferCallTool build() {
            return new TransferCallTool(
                    messages, destinations, id, orgId, createdAt, updatedAt, function, additionalProperties);
        }
    }
}
